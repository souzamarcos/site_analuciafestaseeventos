{"version":3,"sources":["photoswipe.js","photoswipe-ui-default.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"photoswipe.js","sourcesContent":["/*! PhotoSwipe - v4.1.2 - 2017-04-05\r\n * http://photoswipe.com\r\n * Copyright (c) 2017 Dmitry Semenov; */\r\n(function(root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(factory);\r\n    } else if (typeof exports === 'object') {\r\n        module.exports = factory();\r\n    } else {\r\n        root.PhotoSwipe = factory();\r\n    }\r\n})(this, function() {\r\n\r\n    'use strict';\r\n    var PhotoSwipe = function(template, UiClass, items, options) {\r\n\r\n        /*>>framework-bridge*/\r\n        /**\r\n         *\r\n         * Set of generic functions used by gallery.\r\n         * \r\n         * You're free to modify anything here as long as functionality is kept.\r\n         * \r\n         */\r\n        var framework = {\r\n            features: null,\r\n            bind: function(target, type, listener, unbind) {\r\n                var methodName = (unbind ? 'remove' : 'add') + 'EventListener';\r\n                type = type.split(' ');\r\n                for (var i = 0; i < type.length; i++) {\r\n                    if (type[i]) {\r\n                        target[methodName](type[i], listener, false);\r\n                    }\r\n                }\r\n            },\r\n            isArray: function(obj) {\r\n                return (obj instanceof Array);\r\n            },\r\n            createEl: function(classes, tag) {\r\n                var el = document.createElement(tag || 'div');\r\n                if (classes) {\r\n                    el.className = classes;\r\n                }\r\n                return el;\r\n            },\r\n            getScrollY: function() {\r\n                var yOffset = window.pageYOffset;\r\n                return yOffset !== undefined ? yOffset : document.documentElement.scrollTop;\r\n            },\r\n            unbind: function(target, type, listener) {\r\n                framework.bind(target, type, listener, true);\r\n            },\r\n            removeClass: function(el, className) {\r\n                var reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\r\n                el.className = el.className.replace(reg, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\r\n            },\r\n            addClass: function(el, className) {\r\n                if (!framework.hasClass(el, className)) {\r\n                    el.className += (el.className ? ' ' : '') + className;\r\n                }\r\n            },\r\n            hasClass: function(el, className) {\r\n                return el.className && new RegExp('(^|\\\\s)' + className + '(\\\\s|$)').test(el.className);\r\n            },\r\n            getChildByClass: function(parentEl, childClassName) {\r\n                var node = parentEl.firstChild;\r\n                while (node) {\r\n                    if (framework.hasClass(node, childClassName)) {\r\n                        return node;\r\n                    }\r\n                    node = node.nextSibling;\r\n                }\r\n            },\r\n            arraySearch: function(array, value, key) {\r\n                var i = array.length;\r\n                while (i--) {\r\n                    if (array[i][key] === value) {\r\n                        return i;\r\n                    }\r\n                }\r\n                return -1;\r\n            },\r\n            extend: function(o1, o2, preventOverwrite) {\r\n                for (var prop in o2) {\r\n                    if (o2.hasOwnProperty(prop)) {\r\n                        if (preventOverwrite && o1.hasOwnProperty(prop)) {\r\n                            continue;\r\n                        }\r\n                        o1[prop] = o2[prop];\r\n                    }\r\n                }\r\n            },\r\n            easing: {\r\n                sine: {\r\n                    out: function(k) {\r\n                        return Math.sin(k * (Math.PI / 2));\r\n                    },\r\n                    inOut: function(k) {\r\n                        return -(Math.cos(Math.PI * k) - 1) / 2;\r\n                    }\r\n                },\r\n                cubic: {\r\n                    out: function(k) {\r\n                        return --k * k * k + 1;\r\n                    }\r\n                }\r\n                /*\r\n                \telastic: {\r\n                \t\tout: function ( k ) {\r\n                \t\t\tvar s, a = 0.1, p = 0.4;\r\n                \t\t\tif ( k === 0 ) return 0;\r\n                \t\t\tif ( k === 1 ) return 1;\r\n                \t\t\tif ( !a || a < 1 ) { a = 1; s = p / 4; }\r\n                \t\t\telse s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );\r\n                \t\t\treturn ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );\r\n                \t\t},\r\n                \t},\r\n                \tback: {\r\n                \t\tout: function ( k ) {\r\n                \t\t\tvar s = 1.70158;\r\n                \t\t\treturn --k * k * ( ( s + 1 ) * k + s ) + 1;\r\n                \t\t}\r\n                \t}\r\n                */\r\n            },\r\n\r\n            /**\r\n             * \r\n             * @return {object}\r\n             * \r\n             * {\r\n             *  raf : request animation frame function\r\n             *  caf : cancel animation frame function\r\n             *  transfrom : transform property key (with vendor), or null if not supported\r\n             *  oldIE : IE8 or below\r\n             * }\r\n             * \r\n             */\r\n            detectFeatures: function() {\r\n                if (framework.features) {\r\n                    return framework.features;\r\n                }\r\n                var helperEl = framework.createEl(),\r\n                    helperStyle = helperEl.style,\r\n                    vendor = '',\r\n                    features = {};\r\n\r\n                // IE8 and below\r\n                features.oldIE = document.all && !document.addEventListener;\r\n\r\n                features.touch = 'ontouchstart' in window;\r\n\r\n                if (window.requestAnimationFrame) {\r\n                    features.raf = window.requestAnimationFrame;\r\n                    features.caf = window.cancelAnimationFrame;\r\n                }\r\n\r\n                features.pointerEvent = navigator.pointerEnabled || navigator.msPointerEnabled;\r\n\r\n                // fix false-positive detection of old Android in new IE\r\n                // (IE11 ua string contains \"Android 4.0\")\r\n\r\n                if (!features.pointerEvent) {\r\n\r\n                    var ua = navigator.userAgent;\r\n\r\n                    // Detect if device is iPhone or iPod and if it's older than iOS 8\r\n                    // http://stackoverflow.com/a/14223920\r\n                    // \r\n                    // This detection is made because of buggy top/bottom toolbars\r\n                    // that don't trigger window.resize event.\r\n                    // For more info refer to _isFixedPosition variable in core.js\r\n\r\n                    if (/iP(hone|od)/.test(navigator.platform)) {\r\n                        var v = (navigator.appVersion).match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\r\n                        if (v && v.length > 0) {\r\n                            v = parseInt(v[1], 10);\r\n                            if (v >= 1 && v < 8) {\r\n                                features.isOldIOSPhone = true;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Detect old Android (before KitKat)\r\n                    // due to bugs related to position:fixed\r\n                    // http://stackoverflow.com/questions/7184573/pick-up-the-android-version-in-the-browser-by-javascript\r\n\r\n                    var match = ua.match(/Android\\s([0-9\\.]*)/);\r\n                    var androidversion = match ? match[1] : 0;\r\n                    androidversion = parseFloat(androidversion);\r\n                    if (androidversion >= 1) {\r\n                        if (androidversion < 4.4) {\r\n                            features.isOldAndroid = true; // for fixed position bug & performance\r\n                        }\r\n                        features.androidVersion = androidversion; // for touchend bug\r\n                    }\r\n                    features.isMobileOpera = /opera mini|opera mobi/i.test(ua);\r\n\r\n                    // p.s. yes, yes, UA sniffing is bad, propose your solution for above bugs.\r\n                }\r\n\r\n                var styleChecks = ['transform', 'perspective', 'animationName'],\r\n                    vendors = ['', 'webkit', 'Moz', 'ms', 'O'],\r\n                    styleCheckItem,\r\n                    styleName;\r\n\r\n                for (var i = 0; i < 4; i++) {\r\n                    vendor = vendors[i];\r\n\r\n                    for (var a = 0; a < 3; a++) {\r\n                        styleCheckItem = styleChecks[a];\r\n\r\n                        // uppercase first letter of property name, if vendor is present\r\n                        styleName = vendor + (vendor ?\r\n                            styleCheckItem.charAt(0).toUpperCase() + styleCheckItem.slice(1) :\r\n                            styleCheckItem);\r\n\r\n                        if (!features[styleCheckItem] && styleName in helperStyle) {\r\n                            features[styleCheckItem] = styleName;\r\n                        }\r\n                    }\r\n\r\n                    if (vendor && !features.raf) {\r\n                        vendor = vendor.toLowerCase();\r\n                        features.raf = window[vendor + 'RequestAnimationFrame'];\r\n                        if (features.raf) {\r\n                            features.caf = window[vendor + 'CancelAnimationFrame'] ||\r\n                                window[vendor + 'CancelRequestAnimationFrame'];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!features.raf) {\r\n                    var lastTime = 0;\r\n                    features.raf = function(fn) {\r\n                        var currTime = new Date().getTime();\r\n                        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n                        var id = window.setTimeout(function() { fn(currTime + timeToCall); }, timeToCall);\r\n                        lastTime = currTime + timeToCall;\r\n                        return id;\r\n                    };\r\n                    features.caf = function(id) { clearTimeout(id); };\r\n                }\r\n\r\n                // Detect SVG support\r\n                features.svg = !!document.createElementNS &&\r\n                    !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;\r\n\r\n                framework.features = features;\r\n\r\n                return features;\r\n            }\r\n        };\r\n\r\n        framework.detectFeatures();\r\n\r\n        // Override addEventListener for old versions of IE\r\n        if (framework.features.oldIE) {\r\n\r\n            framework.bind = function(target, type, listener, unbind) {\r\n\r\n                type = type.split(' ');\r\n\r\n                var methodName = (unbind ? 'detach' : 'attach') + 'Event',\r\n                    evName,\r\n                    _handleEv = function() {\r\n                        listener.handleEvent.call(listener);\r\n                    };\r\n\r\n                for (var i = 0; i < type.length; i++) {\r\n                    evName = type[i];\r\n                    if (evName) {\r\n\r\n                        if (typeof listener === 'object' && listener.handleEvent) {\r\n                            if (!unbind) {\r\n                                listener['oldIE' + evName] = _handleEv;\r\n                            } else {\r\n                                if (!listener['oldIE' + evName]) {\r\n                                    return false;\r\n                                }\r\n                            }\r\n\r\n                            target[methodName]('on' + evName, listener['oldIE' + evName]);\r\n                        } else {\r\n                            target[methodName]('on' + evName, listener);\r\n                        }\r\n\r\n                    }\r\n                }\r\n            };\r\n\r\n        }\r\n\r\n        /*>>framework-bridge*/\r\n\r\n        /*>>core*/\r\n        //function(template, UiClass, items, options)\r\n\r\n        var self = this;\r\n\r\n        /**\r\n         * Static vars, don't change unless you know what you're doing.\r\n         */\r\n        var DOUBLE_TAP_RADIUS = 25,\r\n            NUM_HOLDERS = 3;\r\n\r\n        /**\r\n         * Options\r\n         */\r\n        var _options = {\r\n            allowPanToNext: true,\r\n            spacing: 0.12,\r\n            bgOpacity: 1,\r\n            mouseUsed: false,\r\n            loop: true,\r\n            pinchToClose: true,\r\n            closeOnScroll: true,\r\n            closeOnVerticalDrag: true,\r\n            verticalDragRange: 0.75,\r\n            hideAnimationDuration: 333,\r\n            showAnimationDuration: 333,\r\n            showHideOpacity: false,\r\n            focus: true,\r\n            escKey: true,\r\n            arrowKeys: true,\r\n            mainScrollEndFriction: 0.35,\r\n            panEndFriction: 0.35,\r\n            isClickableElement: function(el) {\r\n                return el.tagName === 'A';\r\n            },\r\n            getDoubleTapZoom: function(isMouseClick, item) {\r\n                if (isMouseClick) {\r\n                    return 1;\r\n                } else {\r\n                    return item.initialZoomLevel < 0.7 ? 1 : 1.33;\r\n                }\r\n            },\r\n            maxSpreadZoom: 1.33,\r\n            modal: true,\r\n\r\n            // not fully implemented yet\r\n            scaleMode: 'fit' // TODO\r\n        };\r\n        framework.extend(_options, options);\r\n\r\n\r\n        /**\r\n         * Private helper variables & functions\r\n         */\r\n\r\n        var _getEmptyPoint = function() {\r\n            return { x: 0, y: 0 };\r\n        };\r\n\r\n        var _isOpen,\r\n            _isDestroying,\r\n            _closedByScroll,\r\n            _currentItemIndex,\r\n            _containerStyle,\r\n            _containerShiftIndex,\r\n            _currPanDist = _getEmptyPoint(),\r\n            _startPanOffset = _getEmptyPoint(),\r\n            _panOffset = _getEmptyPoint(),\r\n            _upMoveEvents, // drag move, drag end & drag cancel events array\r\n            _downEvents, // drag start events array\r\n            _globalEventHandlers,\r\n            _viewportSize = {},\r\n            _currZoomLevel,\r\n            _startZoomLevel,\r\n            _translatePrefix,\r\n            _translateSufix,\r\n            _updateSizeInterval,\r\n            _itemsNeedUpdate,\r\n            _currPositionIndex = 0,\r\n            _offset = {},\r\n            _slideSize = _getEmptyPoint(), // size of slide area, including spacing\r\n            _itemHolders,\r\n            _prevItemIndex,\r\n            _indexDiff = 0, // difference of indexes since last content update\r\n            _dragStartEvent,\r\n            _dragMoveEvent,\r\n            _dragEndEvent,\r\n            _dragCancelEvent,\r\n            _transformKey,\r\n            _pointerEventEnabled,\r\n            _isFixedPosition = true,\r\n            _likelyTouchDevice,\r\n            _modules = [],\r\n            _requestAF,\r\n            _cancelAF,\r\n            _initalClassName,\r\n            _initalWindowScrollY,\r\n            _oldIE,\r\n            _currentWindowScrollY,\r\n            _features,\r\n            _windowVisibleSize = {},\r\n            _renderMaxResolution = false,\r\n            _orientationChangeTimeout,\r\n\r\n\r\n            // Registers PhotoSWipe module (History, Controller ...)\r\n            _registerModule = function(name, module) {\r\n                framework.extend(self, module.publicMethods);\r\n                _modules.push(name);\r\n            },\r\n\r\n            _getLoopedId = function(index) {\r\n                var numSlides = _getNumItems();\r\n                if (index > numSlides - 1) {\r\n                    return index - numSlides;\r\n                } else if (index < 0) {\r\n                    return numSlides + index;\r\n                }\r\n                return index;\r\n            },\r\n\r\n            // Micro bind/trigger\r\n            _listeners = {},\r\n            _listen = function(name, fn) {\r\n                if (!_listeners[name]) {\r\n                    _listeners[name] = [];\r\n                }\r\n                return _listeners[name].push(fn);\r\n            },\r\n            _shout = function(name) {\r\n                var listeners = _listeners[name];\r\n\r\n                if (listeners) {\r\n                    var args = Array.prototype.slice.call(arguments);\r\n                    args.shift();\r\n\r\n                    for (var i = 0; i < listeners.length; i++) {\r\n                        listeners[i].apply(self, args);\r\n                    }\r\n                }\r\n            },\r\n\r\n            _getCurrentTime = function() {\r\n                return new Date().getTime();\r\n            },\r\n            _applyBgOpacity = function(opacity) {\r\n                _bgOpacity = opacity;\r\n                self.bg.style.opacity = opacity * _options.bgOpacity;\r\n            },\r\n\r\n            _applyZoomTransform = function(styleObj, x, y, zoom, item) {\r\n                if (!_renderMaxResolution || (item && item !== self.currItem)) {\r\n                    zoom = zoom / (item ? item.fitRatio : self.currItem.fitRatio);\r\n                }\r\n\r\n                styleObj[_transformKey] = _translatePrefix + x + 'px, ' + y + 'px' + _translateSufix + ' scale(' + zoom + ')';\r\n            },\r\n            _applyCurrentZoomPan = function(allowRenderResolution) {\r\n                if (_currZoomElementStyle) {\r\n\r\n                    if (allowRenderResolution) {\r\n                        if (_currZoomLevel > self.currItem.fitRatio) {\r\n                            if (!_renderMaxResolution) {\r\n                                _setImageSize(self.currItem, false, true);\r\n                                _renderMaxResolution = true;\r\n                            }\r\n                        } else {\r\n                            if (_renderMaxResolution) {\r\n                                _setImageSize(self.currItem);\r\n                                _renderMaxResolution = false;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n\r\n                    _applyZoomTransform(_currZoomElementStyle, _panOffset.x, _panOffset.y, _currZoomLevel);\r\n                }\r\n            },\r\n            _applyZoomPanToItem = function(item) {\r\n                if (item.container) {\r\n\r\n                    _applyZoomTransform(item.container.style,\r\n                        item.initialPosition.x,\r\n                        item.initialPosition.y,\r\n                        item.initialZoomLevel,\r\n                        item);\r\n                }\r\n            },\r\n            _setTranslateX = function(x, elStyle) {\r\n                elStyle[_transformKey] = _translatePrefix + x + 'px, 0px' + _translateSufix;\r\n            },\r\n            _moveMainScroll = function(x, dragging) {\r\n\r\n                if (!_options.loop && dragging) {\r\n                    var newSlideIndexOffset = _currentItemIndex + (_slideSize.x * _currPositionIndex - x) / _slideSize.x,\r\n                        delta = Math.round(x - _mainScrollPos.x);\r\n\r\n                    if ((newSlideIndexOffset < 0 && delta > 0) ||\r\n                        (newSlideIndexOffset >= _getNumItems() - 1 && delta < 0)) {\r\n                        x = _mainScrollPos.x + delta * _options.mainScrollEndFriction;\r\n                    }\r\n                }\r\n\r\n                _mainScrollPos.x = x;\r\n                _setTranslateX(x, _containerStyle);\r\n            },\r\n            _calculatePanOffset = function(axis, zoomLevel) {\r\n                var m = _midZoomPoint[axis] - _offset[axis];\r\n                return _startPanOffset[axis] + _currPanDist[axis] + m - m * (zoomLevel / _startZoomLevel);\r\n            },\r\n\r\n            _equalizePoints = function(p1, p2) {\r\n                p1.x = p2.x;\r\n                p1.y = p2.y;\r\n                if (p2.id) {\r\n                    p1.id = p2.id;\r\n                }\r\n            },\r\n            _roundPoint = function(p) {\r\n                p.x = Math.round(p.x);\r\n                p.y = Math.round(p.y);\r\n            },\r\n\r\n            _mouseMoveTimeout = null,\r\n            _onFirstMouseMove = function() {\r\n                // Wait until mouse move event is fired at least twice during 100ms\r\n                // We do this, because some mobile browsers trigger it on touchstart\r\n                if (_mouseMoveTimeout) {\r\n                    framework.unbind(document, 'mousemove', _onFirstMouseMove);\r\n                    framework.addClass(template, 'pswp--has_mouse');\r\n                    _options.mouseUsed = true;\r\n                    _shout('mouseUsed');\r\n                }\r\n                _mouseMoveTimeout = setTimeout(function() {\r\n                    _mouseMoveTimeout = null;\r\n                }, 100);\r\n            },\r\n\r\n            _bindEvents = function() {\r\n                framework.bind(document, 'keydown', self);\r\n\r\n                if (_features.transform) {\r\n                    // don't bind click event in browsers that don't support transform (mostly IE8)\r\n                    framework.bind(self.scrollWrap, 'click', self);\r\n                }\r\n\r\n\r\n                if (!_options.mouseUsed) {\r\n                    framework.bind(document, 'mousemove', _onFirstMouseMove);\r\n                }\r\n\r\n                framework.bind(window, 'resize scroll orientationchange', self);\r\n\r\n                _shout('bindEvents');\r\n            },\r\n\r\n            _unbindEvents = function() {\r\n                framework.unbind(window, 'resize scroll orientationchange', self);\r\n                framework.unbind(window, 'scroll', _globalEventHandlers.scroll);\r\n                framework.unbind(document, 'keydown', self);\r\n                framework.unbind(document, 'mousemove', _onFirstMouseMove);\r\n\r\n                if (_features.transform) {\r\n                    framework.unbind(self.scrollWrap, 'click', self);\r\n                }\r\n\r\n                if (_isDragging) {\r\n                    framework.unbind(window, _upMoveEvents, self);\r\n                }\r\n\r\n                clearTimeout(_orientationChangeTimeout);\r\n\r\n                _shout('unbindEvents');\r\n            },\r\n\r\n            _calculatePanBounds = function(zoomLevel, update) {\r\n                var bounds = _calculateItemSize(self.currItem, _viewportSize, zoomLevel);\r\n                if (update) {\r\n                    _currPanBounds = bounds;\r\n                }\r\n                return bounds;\r\n            },\r\n\r\n            _getMinZoomLevel = function(item) {\r\n                if (!item) {\r\n                    item = self.currItem;\r\n                }\r\n                return item.initialZoomLevel;\r\n            },\r\n            _getMaxZoomLevel = function(item) {\r\n                if (!item) {\r\n                    item = self.currItem;\r\n                }\r\n                return item.w > 0 ? _options.maxSpreadZoom : 1;\r\n            },\r\n\r\n            // Return true if offset is out of the bounds\r\n            _modifyDestPanOffset = function(axis, destPanBounds, destPanOffset, destZoomLevel) {\r\n                if (destZoomLevel === self.currItem.initialZoomLevel) {\r\n                    destPanOffset[axis] = self.currItem.initialPosition[axis];\r\n                    return true;\r\n                } else {\r\n                    destPanOffset[axis] = _calculatePanOffset(axis, destZoomLevel);\r\n\r\n                    if (destPanOffset[axis] > destPanBounds.min[axis]) {\r\n                        destPanOffset[axis] = destPanBounds.min[axis];\r\n                        return true;\r\n                    } else if (destPanOffset[axis] < destPanBounds.max[axis]) {\r\n                        destPanOffset[axis] = destPanBounds.max[axis];\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            },\r\n\r\n            _setupTransforms = function() {\r\n\r\n                if (_transformKey) {\r\n                    // setup 3d transforms\r\n                    var allow3dTransform = _features.perspective && !_likelyTouchDevice;\r\n                    _translatePrefix = 'translate' + (allow3dTransform ? '3d(' : '(');\r\n                    _translateSufix = _features.perspective ? ', 0px)' : ')';\r\n                    return;\r\n                }\r\n\r\n                // Override zoom/pan/move functions in case old browser is used (most likely IE)\r\n                // (so they use left/top/width/height, instead of CSS transform)\r\n\r\n                _transformKey = 'left';\r\n                framework.addClass(template, 'pswp--ie');\r\n\r\n                _setTranslateX = function(x, elStyle) {\r\n                    elStyle.left = x + 'px';\r\n                };\r\n                _applyZoomPanToItem = function(item) {\r\n\r\n                    var zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,\r\n                        s = item.container.style,\r\n                        w = zoomRatio * item.w,\r\n                        h = zoomRatio * item.h;\r\n\r\n                    s.width = w + 'px';\r\n                    s.height = h + 'px';\r\n                    s.left = item.initialPosition.x + 'px';\r\n                    s.top = item.initialPosition.y + 'px';\r\n\r\n                };\r\n                _applyCurrentZoomPan = function() {\r\n                    if (_currZoomElementStyle) {\r\n\r\n                        var s = _currZoomElementStyle,\r\n                            item = self.currItem,\r\n                            zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,\r\n                            w = zoomRatio * item.w,\r\n                            h = zoomRatio * item.h;\r\n\r\n                        s.width = w + 'px';\r\n                        s.height = h + 'px';\r\n\r\n\r\n                        s.left = _panOffset.x + 'px';\r\n                        s.top = _panOffset.y + 'px';\r\n                    }\r\n\r\n                };\r\n            },\r\n\r\n            _onKeyDown = function(e) {\r\n                var keydownAction = '';\r\n                if (_options.escKey && e.keyCode === 27) {\r\n                    keydownAction = 'close';\r\n                } else if (_options.arrowKeys) {\r\n                    if (e.keyCode === 37) {\r\n                        keydownAction = 'prev';\r\n                    } else if (e.keyCode === 39) {\r\n                        keydownAction = 'next';\r\n                    }\r\n                }\r\n\r\n                if (keydownAction) {\r\n                    // don't do anything if special key pressed to prevent from overriding default browser actions\r\n                    // e.g. in Chrome on Mac cmd+arrow-left returns to previous page\r\n                    if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey) {\r\n                        if (e.preventDefault) {\r\n                            e.preventDefault();\r\n                        } else {\r\n                            e.returnValue = false;\r\n                        }\r\n                        self[keydownAction]();\r\n                    }\r\n                }\r\n            },\r\n\r\n            _onGlobalClick = function(e) {\r\n                if (!e) {\r\n                    return;\r\n                }\r\n\r\n                // don't allow click event to pass through when triggering after drag or some other gesture\r\n                if (_moved || _zoomStarted || _mainScrollAnimating || _verticalDragInitiated) {\r\n                    e.preventDefault();\r\n                    e.stopPropagation();\r\n                }\r\n            },\r\n\r\n            _updatePageScrollOffset = function() {\r\n                self.setScrollOffset(0, framework.getScrollY());\r\n            };\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // Micro animation engine\r\n        var _animations = {},\r\n            _numAnimations = 0,\r\n            _stopAnimation = function(name) {\r\n                if (_animations[name]) {\r\n                    if (_animations[name].raf) {\r\n                        _cancelAF(_animations[name].raf);\r\n                    }\r\n                    _numAnimations--;\r\n                    delete _animations[name];\r\n                }\r\n            },\r\n            _registerStartAnimation = function(name) {\r\n                if (_animations[name]) {\r\n                    _stopAnimation(name);\r\n                }\r\n                if (!_animations[name]) {\r\n                    _numAnimations++;\r\n                    _animations[name] = {};\r\n                }\r\n            },\r\n            _stopAllAnimations = function() {\r\n                for (var prop in _animations) {\r\n\r\n                    if (_animations.hasOwnProperty(prop)) {\r\n                        _stopAnimation(prop);\r\n                    }\r\n\r\n                }\r\n            },\r\n            _animateProp = function(name, b, endProp, d, easingFn, onUpdate, onComplete) {\r\n                var startAnimTime = _getCurrentTime(),\r\n                    t;\r\n                _registerStartAnimation(name);\r\n\r\n                var animloop = function() {\r\n                    if (_animations[name]) {\r\n\r\n                        t = _getCurrentTime() - startAnimTime; // time diff\r\n                        //b - beginning (start prop)\r\n                        //d - anim duration\r\n\r\n                        if (t >= d) {\r\n                            _stopAnimation(name);\r\n                            onUpdate(endProp);\r\n                            if (onComplete) {\r\n                                onComplete();\r\n                            }\r\n                            return;\r\n                        }\r\n                        onUpdate((endProp - b) * easingFn(t / d) + b);\r\n\r\n                        _animations[name].raf = _requestAF(animloop);\r\n                    }\r\n                };\r\n                animloop();\r\n            };\r\n\r\n\r\n\r\n        var publicMethods = {\r\n\r\n            // make a few local variables and functions public\r\n            shout: _shout,\r\n            listen: _listen,\r\n            viewportSize: _viewportSize,\r\n            options: _options,\r\n\r\n            isMainScrollAnimating: function() {\r\n                return _mainScrollAnimating;\r\n            },\r\n            getZoomLevel: function() {\r\n                return _currZoomLevel;\r\n            },\r\n            getCurrentIndex: function() {\r\n                return _currentItemIndex;\r\n            },\r\n            isDragging: function() {\r\n                return _isDragging;\r\n            },\r\n            isZooming: function() {\r\n                return _isZooming;\r\n            },\r\n            setScrollOffset: function(x, y) {\r\n                _offset.x = x;\r\n                _currentWindowScrollY = _offset.y = y;\r\n                _shout('updateScrollOffset', _offset);\r\n            },\r\n            applyZoomPan: function(zoomLevel, panX, panY, allowRenderResolution) {\r\n                _panOffset.x = panX;\r\n                _panOffset.y = panY;\r\n                _currZoomLevel = zoomLevel;\r\n                _applyCurrentZoomPan(allowRenderResolution);\r\n            },\r\n\r\n            init: function() {\r\n\r\n                if (_isOpen || _isDestroying) {\r\n                    return;\r\n                }\r\n\r\n                var i;\r\n\r\n                self.framework = framework; // basic functionality\r\n                self.template = template; // root DOM element of PhotoSwipe\r\n                self.bg = framework.getChildByClass(template, 'pswp__bg');\r\n\r\n                _initalClassName = template.className;\r\n                _isOpen = true;\r\n\r\n                _features = framework.detectFeatures();\r\n                _requestAF = _features.raf;\r\n                _cancelAF = _features.caf;\r\n                _transformKey = _features.transform;\r\n                _oldIE = _features.oldIE;\r\n\r\n                self.scrollWrap = framework.getChildByClass(template, 'pswp__scroll-wrap');\r\n                self.container = framework.getChildByClass(self.scrollWrap, 'pswp__container');\r\n\r\n                _containerStyle = self.container.style; // for fast access\r\n\r\n                // Objects that hold slides (there are only 3 in DOM)\r\n                self.itemHolders = _itemHolders = [\r\n                    { el: self.container.children[0], wrap: 0, index: -1 },\r\n                    { el: self.container.children[1], wrap: 0, index: -1 },\r\n                    { el: self.container.children[2], wrap: 0, index: -1 }\r\n                ];\r\n\r\n                // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)\r\n                _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'none';\r\n\r\n                _setupTransforms();\r\n\r\n                // Setup global events\r\n                _globalEventHandlers = {\r\n                    resize: self.updateSize,\r\n\r\n                    // Fixes: iOS 10.3 resize event\r\n                    // does not update scrollWrap.clientWidth instantly after resize\r\n                    // https://github.com/dimsemenov/PhotoSwipe/issues/1315\r\n                    orientationchange: function() {\r\n                        clearTimeout(_orientationChangeTimeout);\r\n                        _orientationChangeTimeout = setTimeout(function() {\r\n                            if (_viewportSize.x !== self.scrollWrap.clientWidth) {\r\n                                self.updateSize();\r\n                            }\r\n                        }, 500);\r\n                    },\r\n                    scroll: _updatePageScrollOffset,\r\n                    keydown: _onKeyDown,\r\n                    click: _onGlobalClick\r\n                };\r\n\r\n                // disable show/hide effects on old browsers that don't support CSS animations or transforms, \r\n                // old IOS, Android and Opera mobile. Blackberry seems to work fine, even older models.\r\n                var oldPhone = _features.isOldIOSPhone || _features.isOldAndroid || _features.isMobileOpera;\r\n                if (!_features.animationName || !_features.transform || oldPhone) {\r\n                    _options.showAnimationDuration = _options.hideAnimationDuration = 0;\r\n                }\r\n\r\n                // init modules\r\n                for (i = 0; i < _modules.length; i++) {\r\n                    self['init' + _modules[i]]();\r\n                }\r\n\r\n                // init\r\n                if (UiClass) {\r\n                    var ui = self.ui = new UiClass(self, framework);\r\n                    ui.init();\r\n                }\r\n\r\n                _shout('firstUpdate');\r\n                _currentItemIndex = _currentItemIndex || _options.index || 0;\r\n                // validate index\r\n                if (isNaN(_currentItemIndex) || _currentItemIndex < 0 || _currentItemIndex >= _getNumItems()) {\r\n                    _currentItemIndex = 0;\r\n                }\r\n                self.currItem = _getItemAt(_currentItemIndex);\r\n\r\n\r\n                if (_features.isOldIOSPhone || _features.isOldAndroid) {\r\n                    _isFixedPosition = false;\r\n                }\r\n\r\n                template.setAttribute('aria-hidden', 'false');\r\n                if (_options.modal) {\r\n                    if (!_isFixedPosition) {\r\n                        template.style.position = 'absolute';\r\n                        template.style.top = framework.getScrollY() + 'px';\r\n                    } else {\r\n                        template.style.position = 'fixed';\r\n                    }\r\n                }\r\n\r\n                if (_currentWindowScrollY === undefined) {\r\n                    _shout('initialLayout');\r\n                    _currentWindowScrollY = _initalWindowScrollY = framework.getScrollY();\r\n                }\r\n\r\n                // add classes to root element of PhotoSwipe\r\n                var rootClasses = 'pswp--open ';\r\n                if (_options.mainClass) {\r\n                    rootClasses += _options.mainClass + ' ';\r\n                }\r\n                if (_options.showHideOpacity) {\r\n                    rootClasses += 'pswp--animate_opacity ';\r\n                }\r\n                rootClasses += _likelyTouchDevice ? 'pswp--touch' : 'pswp--notouch';\r\n                rootClasses += _features.animationName ? ' pswp--css_animation' : '';\r\n                rootClasses += _features.svg ? ' pswp--svg' : '';\r\n                framework.addClass(template, rootClasses);\r\n\r\n                self.updateSize();\r\n\r\n                // initial update\r\n                _containerShiftIndex = -1;\r\n                _indexDiff = null;\r\n                for (i = 0; i < NUM_HOLDERS; i++) {\r\n                    _setTranslateX((i + _containerShiftIndex) * _slideSize.x, _itemHolders[i].el.style);\r\n                }\r\n\r\n                if (!_oldIE) {\r\n                    framework.bind(self.scrollWrap, _downEvents, self); // no dragging for old IE\r\n                }\r\n\r\n                _listen('initialZoomInEnd', function() {\r\n                    self.setContent(_itemHolders[0], _currentItemIndex - 1);\r\n                    self.setContent(_itemHolders[2], _currentItemIndex + 1);\r\n\r\n                    _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'block';\r\n\r\n                    if (_options.focus) {\r\n                        // focus causes layout, \r\n                        // which causes lag during the animation, \r\n                        // that's why we delay it untill the initial zoom transition ends\r\n                        template.focus();\r\n                    }\r\n\r\n\r\n                    _bindEvents();\r\n                });\r\n\r\n                // set content for center slide (first time)\r\n                self.setContent(_itemHolders[1], _currentItemIndex);\r\n\r\n                self.updateCurrItem();\r\n\r\n                _shout('afterInit');\r\n\r\n                if (!_isFixedPosition) {\r\n\r\n                    // On all versions of iOS lower than 8.0, we check size of viewport every second.\r\n                    // \r\n                    // This is done to detect when Safari top & bottom bars appear, \r\n                    // as this action doesn't trigger any events (like resize). \r\n                    // \r\n                    // On iOS8 they fixed this.\r\n                    // \r\n                    // 10 Nov 2014: iOS 7 usage ~40%. iOS 8 usage 56%.\r\n\r\n                    _updateSizeInterval = setInterval(function() {\r\n                        if (!_numAnimations && !_isDragging && !_isZooming && (_currZoomLevel === self.currItem.initialZoomLevel)) {\r\n                            self.updateSize();\r\n                        }\r\n                    }, 1000);\r\n                }\r\n\r\n                framework.addClass(template, 'pswp--visible');\r\n            },\r\n\r\n            // Close the gallery, then destroy it\r\n            close: function() {\r\n                if (!_isOpen) {\r\n                    return;\r\n                }\r\n\r\n                _isOpen = false;\r\n                _isDestroying = true;\r\n                _shout('close');\r\n                _unbindEvents();\r\n\r\n                _showOrHide(self.currItem, null, true, self.destroy);\r\n            },\r\n\r\n            // destroys the gallery (unbinds events, cleans up intervals and timeouts to avoid memory leaks)\r\n            destroy: function() {\r\n                _shout('destroy');\r\n\r\n                if (_showOrHideTimeout) {\r\n                    clearTimeout(_showOrHideTimeout);\r\n                }\r\n\r\n                template.setAttribute('aria-hidden', 'true');\r\n                template.className = _initalClassName;\r\n\r\n                if (_updateSizeInterval) {\r\n                    clearInterval(_updateSizeInterval);\r\n                }\r\n\r\n                framework.unbind(self.scrollWrap, _downEvents, self);\r\n\r\n                // we unbind scroll event at the end, as closing animation may depend on it\r\n                framework.unbind(window, 'scroll', self);\r\n\r\n                _stopDragUpdateLoop();\r\n\r\n                _stopAllAnimations();\r\n\r\n                _listeners = null;\r\n            },\r\n\r\n            /**\r\n             * Pan image to position\r\n             * @param {Number} x     \r\n             * @param {Number} y     \r\n             * @param {Boolean} force Will ignore bounds if set to true.\r\n             */\r\n            panTo: function(x, y, force) {\r\n                if (!force) {\r\n                    if (x > _currPanBounds.min.x) {\r\n                        x = _currPanBounds.min.x;\r\n                    } else if (x < _currPanBounds.max.x) {\r\n                        x = _currPanBounds.max.x;\r\n                    }\r\n\r\n                    if (y > _currPanBounds.min.y) {\r\n                        y = _currPanBounds.min.y;\r\n                    } else if (y < _currPanBounds.max.y) {\r\n                        y = _currPanBounds.max.y;\r\n                    }\r\n                }\r\n\r\n                _panOffset.x = x;\r\n                _panOffset.y = y;\r\n                _applyCurrentZoomPan();\r\n            },\r\n\r\n            handleEvent: function(e) {\r\n                e = e || window.event;\r\n                if (_globalEventHandlers[e.type]) {\r\n                    _globalEventHandlers[e.type](e);\r\n                }\r\n            },\r\n\r\n\r\n            goTo: function(index) {\r\n\r\n                index = _getLoopedId(index);\r\n\r\n                var diff = index - _currentItemIndex;\r\n                _indexDiff = diff;\r\n\r\n                _currentItemIndex = index;\r\n                self.currItem = _getItemAt(_currentItemIndex);\r\n                _currPositionIndex -= diff;\r\n\r\n                _moveMainScroll(_slideSize.x * _currPositionIndex);\r\n\r\n\r\n                _stopAllAnimations();\r\n                _mainScrollAnimating = false;\r\n\r\n                self.updateCurrItem();\r\n            },\r\n            next: function() {\r\n                self.goTo(_currentItemIndex + 1);\r\n            },\r\n            prev: function() {\r\n                self.goTo(_currentItemIndex - 1);\r\n            },\r\n\r\n            // update current zoom/pan objects\r\n            updateCurrZoomItem: function(emulateSetContent) {\r\n                if (emulateSetContent) {\r\n                    _shout('beforeChange', 0);\r\n                }\r\n\r\n                // itemHolder[1] is middle (current) item\r\n                if (_itemHolders[1].el.children.length) {\r\n                    var zoomElement = _itemHolders[1].el.children[0];\r\n                    if (framework.hasClass(zoomElement, 'pswp__zoom-wrap')) {\r\n                        _currZoomElementStyle = zoomElement.style;\r\n                    } else {\r\n                        _currZoomElementStyle = null;\r\n                    }\r\n                } else {\r\n                    _currZoomElementStyle = null;\r\n                }\r\n\r\n                _currPanBounds = self.currItem.bounds;\r\n                _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;\r\n\r\n                _panOffset.x = _currPanBounds.center.x;\r\n                _panOffset.y = _currPanBounds.center.y;\r\n\r\n                if (emulateSetContent) {\r\n                    _shout('afterChange');\r\n                }\r\n            },\r\n\r\n\r\n            invalidateCurrItems: function() {\r\n                _itemsNeedUpdate = true;\r\n                for (var i = 0; i < NUM_HOLDERS; i++) {\r\n                    if (_itemHolders[i].item) {\r\n                        _itemHolders[i].item.needsUpdate = true;\r\n                    }\r\n                }\r\n            },\r\n\r\n            updateCurrItem: function(beforeAnimation) {\r\n\r\n                if (_indexDiff === 0) {\r\n                    return;\r\n                }\r\n\r\n                var diffAbs = Math.abs(_indexDiff),\r\n                    tempHolder;\r\n\r\n                if (beforeAnimation && diffAbs < 2) {\r\n                    return;\r\n                }\r\n\r\n\r\n                self.currItem = _getItemAt(_currentItemIndex);\r\n                _renderMaxResolution = false;\r\n\r\n                _shout('beforeChange', _indexDiff);\r\n\r\n                if (diffAbs >= NUM_HOLDERS) {\r\n                    _containerShiftIndex += _indexDiff + (_indexDiff > 0 ? -NUM_HOLDERS : NUM_HOLDERS);\r\n                    diffAbs = NUM_HOLDERS;\r\n                }\r\n                for (var i = 0; i < diffAbs; i++) {\r\n                    if (_indexDiff > 0) {\r\n                        tempHolder = _itemHolders.shift();\r\n                        _itemHolders[NUM_HOLDERS - 1] = tempHolder; // move first to last\r\n\r\n                        _containerShiftIndex++;\r\n                        _setTranslateX((_containerShiftIndex + 2) * _slideSize.x, tempHolder.el.style);\r\n                        self.setContent(tempHolder, _currentItemIndex - diffAbs + i + 1 + 1);\r\n                    } else {\r\n                        tempHolder = _itemHolders.pop();\r\n                        _itemHolders.unshift(tempHolder); // move last to first\r\n\r\n                        _containerShiftIndex--;\r\n                        _setTranslateX(_containerShiftIndex * _slideSize.x, tempHolder.el.style);\r\n                        self.setContent(tempHolder, _currentItemIndex + diffAbs - i - 1 - 1);\r\n                    }\r\n\r\n                }\r\n\r\n                // reset zoom/pan on previous item\r\n                if (_currZoomElementStyle && Math.abs(_indexDiff) === 1) {\r\n\r\n                    var prevItem = _getItemAt(_prevItemIndex);\r\n                    if (prevItem.initialZoomLevel !== _currZoomLevel) {\r\n                        _calculateItemSize(prevItem, _viewportSize);\r\n                        _setImageSize(prevItem);\r\n                        _applyZoomPanToItem(prevItem);\r\n                    }\r\n\r\n                }\r\n\r\n                // reset diff after update\r\n                _indexDiff = 0;\r\n\r\n                self.updateCurrZoomItem();\r\n\r\n                _prevItemIndex = _currentItemIndex;\r\n\r\n                _shout('afterChange');\r\n\r\n            },\r\n\r\n\r\n\r\n            updateSize: function(force) {\r\n\r\n                if (!_isFixedPosition && _options.modal) {\r\n                    var windowScrollY = framework.getScrollY();\r\n                    if (_currentWindowScrollY !== windowScrollY) {\r\n                        template.style.top = windowScrollY + 'px';\r\n                        _currentWindowScrollY = windowScrollY;\r\n                    }\r\n                    if (!force && _windowVisibleSize.x === window.innerWidth && _windowVisibleSize.y === window.innerHeight) {\r\n                        return;\r\n                    }\r\n                    _windowVisibleSize.x = window.innerWidth;\r\n                    _windowVisibleSize.y = window.innerHeight;\r\n\r\n                    //template.style.width = _windowVisibleSize.x + 'px';\r\n                    template.style.height = _windowVisibleSize.y + 'px';\r\n                }\r\n\r\n\r\n\r\n                _viewportSize.x = self.scrollWrap.clientWidth;\r\n                _viewportSize.y = self.scrollWrap.clientHeight;\r\n\r\n                _updatePageScrollOffset();\r\n\r\n                _slideSize.x = _viewportSize.x + Math.round(_viewportSize.x * _options.spacing);\r\n                _slideSize.y = _viewportSize.y;\r\n\r\n                _moveMainScroll(_slideSize.x * _currPositionIndex);\r\n\r\n                _shout('beforeResize'); // even may be used for example to switch image sources\r\n\r\n\r\n                // don't re-calculate size on inital size update\r\n                if (_containerShiftIndex !== undefined) {\r\n\r\n                    var holder,\r\n                        item,\r\n                        hIndex;\r\n\r\n                    for (var i = 0; i < NUM_HOLDERS; i++) {\r\n                        holder = _itemHolders[i];\r\n                        _setTranslateX((i + _containerShiftIndex) * _slideSize.x, holder.el.style);\r\n\r\n                        hIndex = _currentItemIndex + i - 1;\r\n\r\n                        if (_options.loop && _getNumItems() > 2) {\r\n                            hIndex = _getLoopedId(hIndex);\r\n                        }\r\n\r\n                        // update zoom level on items and refresh source (if needsUpdate)\r\n                        item = _getItemAt(hIndex);\r\n\r\n                        // re-render gallery item if `needsUpdate`,\r\n                        // or doesn't have `bounds` (entirely new slide object)\r\n                        if (item && (_itemsNeedUpdate || item.needsUpdate || !item.bounds)) {\r\n\r\n                            self.cleanSlide(item);\r\n\r\n                            self.setContent(holder, hIndex);\r\n\r\n                            // if \"center\" slide\r\n                            if (i === 1) {\r\n                                self.currItem = item;\r\n                                self.updateCurrZoomItem(true);\r\n                            }\r\n\r\n                            item.needsUpdate = false;\r\n\r\n                        } else if (holder.index === -1 && hIndex >= 0) {\r\n                            // add content first time\r\n                            self.setContent(holder, hIndex);\r\n                        }\r\n                        if (item && item.container) {\r\n                            _calculateItemSize(item, _viewportSize);\r\n                            _setImageSize(item);\r\n                            _applyZoomPanToItem(item);\r\n                        }\r\n\r\n                    }\r\n                    _itemsNeedUpdate = false;\r\n                }\r\n\r\n                _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;\r\n                _currPanBounds = self.currItem.bounds;\r\n\r\n                if (_currPanBounds) {\r\n                    _panOffset.x = _currPanBounds.center.x;\r\n                    _panOffset.y = _currPanBounds.center.y;\r\n                    _applyCurrentZoomPan(true);\r\n                }\r\n\r\n                _shout('resize');\r\n            },\r\n\r\n            // Zoom current item to\r\n            zoomTo: function(destZoomLevel, centerPoint, speed, easingFn, updateFn) {\r\n                /*\r\n                \tif(destZoomLevel === 'fit') {\r\n                \t\tdestZoomLevel = self.currItem.fitRatio;\r\n                \t} else if(destZoomLevel === 'fill') {\r\n                \t\tdestZoomLevel = self.currItem.fillRatio;\r\n                \t}\r\n                */\r\n\r\n                if (centerPoint) {\r\n                    _startZoomLevel = _currZoomLevel;\r\n                    _midZoomPoint.x = Math.abs(centerPoint.x) - _panOffset.x;\r\n                    _midZoomPoint.y = Math.abs(centerPoint.y) - _panOffset.y;\r\n                    _equalizePoints(_startPanOffset, _panOffset);\r\n                }\r\n\r\n                var destPanBounds = _calculatePanBounds(destZoomLevel, false),\r\n                    destPanOffset = {};\r\n\r\n                _modifyDestPanOffset('x', destPanBounds, destPanOffset, destZoomLevel);\r\n                _modifyDestPanOffset('y', destPanBounds, destPanOffset, destZoomLevel);\r\n\r\n                var initialZoomLevel = _currZoomLevel;\r\n                var initialPanOffset = {\r\n                    x: _panOffset.x,\r\n                    y: _panOffset.y\r\n                };\r\n\r\n                _roundPoint(destPanOffset);\r\n\r\n                var onUpdate = function(now) {\r\n                    if (now === 1) {\r\n                        _currZoomLevel = destZoomLevel;\r\n                        _panOffset.x = destPanOffset.x;\r\n                        _panOffset.y = destPanOffset.y;\r\n                    } else {\r\n                        _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;\r\n                        _panOffset.x = (destPanOffset.x - initialPanOffset.x) * now + initialPanOffset.x;\r\n                        _panOffset.y = (destPanOffset.y - initialPanOffset.y) * now + initialPanOffset.y;\r\n                    }\r\n\r\n                    if (updateFn) {\r\n                        updateFn(now);\r\n                    }\r\n\r\n                    _applyCurrentZoomPan(now === 1);\r\n                };\r\n\r\n                if (speed) {\r\n                    _animateProp('customZoomTo', 0, 1, speed, easingFn || framework.easing.sine.inOut, onUpdate);\r\n                } else {\r\n                    onUpdate(1);\r\n                }\r\n            }\r\n\r\n\r\n        };\r\n\r\n\r\n        /*>>core*/\r\n\r\n        /*>>gestures*/\r\n        /**\r\n         * Mouse/touch/pointer event handlers.\r\n         * \r\n         * separated from @core.js for readability\r\n         */\r\n\r\n        var MIN_SWIPE_DISTANCE = 30,\r\n            DIRECTION_CHECK_OFFSET = 10; // amount of pixels to drag to determine direction of swipe\r\n\r\n        var _gestureStartTime,\r\n            _gestureCheckSpeedTime,\r\n\r\n            // pool of objects that are used during dragging of zooming\r\n            p = {}, // first point\r\n            p2 = {}, // second point (for zoom gesture)\r\n            delta = {},\r\n            _currPoint = {},\r\n            _startPoint = {},\r\n            _currPointers = [],\r\n            _startMainScrollPos = {},\r\n            _releaseAnimData,\r\n            _posPoints = [], // array of points during dragging, used to determine type of gesture\r\n            _tempPoint = {},\r\n\r\n            _isZoomingIn,\r\n            _verticalDragInitiated,\r\n            _oldAndroidTouchEndTimeout,\r\n            _currZoomedItemIndex = 0,\r\n            _centerPoint = _getEmptyPoint(),\r\n            _lastReleaseTime = 0,\r\n            _isDragging, // at least one pointer is down\r\n            _isMultitouch, // at least two _pointers are down\r\n            _zoomStarted, // zoom level changed during zoom gesture\r\n            _moved,\r\n            _dragAnimFrame,\r\n            _mainScrollShifted,\r\n            _currentPoints, // array of current touch points\r\n            _isZooming,\r\n            _currPointsDistance,\r\n            _startPointsDistance,\r\n            _currPanBounds,\r\n            _mainScrollPos = _getEmptyPoint(),\r\n            _currZoomElementStyle,\r\n            _mainScrollAnimating, // true, if animation after swipe gesture is running\r\n            _midZoomPoint = _getEmptyPoint(),\r\n            _currCenterPoint = _getEmptyPoint(),\r\n            _direction,\r\n            _isFirstMove,\r\n            _opacityChanged,\r\n            _bgOpacity,\r\n            _wasOverInitialZoom,\r\n\r\n            _isEqualPoints = function(p1, p2) {\r\n                return p1.x === p2.x && p1.y === p2.y;\r\n            },\r\n            _isNearbyPoints = function(touch0, touch1) {\r\n                return Math.abs(touch0.x - touch1.x) < DOUBLE_TAP_RADIUS && Math.abs(touch0.y - touch1.y) < DOUBLE_TAP_RADIUS;\r\n            },\r\n            _calculatePointsDistance = function(p1, p2) {\r\n                _tempPoint.x = Math.abs(p1.x - p2.x);\r\n                _tempPoint.y = Math.abs(p1.y - p2.y);\r\n                return Math.sqrt(_tempPoint.x * _tempPoint.x + _tempPoint.y * _tempPoint.y);\r\n            },\r\n            _stopDragUpdateLoop = function() {\r\n                if (_dragAnimFrame) {\r\n                    _cancelAF(_dragAnimFrame);\r\n                    _dragAnimFrame = null;\r\n                }\r\n            },\r\n            _dragUpdateLoop = function() {\r\n                if (_isDragging) {\r\n                    _dragAnimFrame = _requestAF(_dragUpdateLoop);\r\n                    _renderMovement();\r\n                }\r\n            },\r\n            _canPan = function() {\r\n                return !(_options.scaleMode === 'fit' && _currZoomLevel === self.currItem.initialZoomLevel);\r\n            },\r\n\r\n            // find the closest parent DOM element\r\n            _closestElement = function(el, fn) {\r\n                if (!el || el === document) {\r\n                    return false;\r\n                }\r\n\r\n                // don't search elements above pswp__scroll-wrap\r\n                if (el.getAttribute('class') && el.getAttribute('class').indexOf('pswp__scroll-wrap') > -1) {\r\n                    return false;\r\n                }\r\n\r\n                if (fn(el)) {\r\n                    return el;\r\n                }\r\n\r\n                return _closestElement(el.parentNode, fn);\r\n            },\r\n\r\n            _preventObj = {},\r\n            _preventDefaultEventBehaviour = function(e, isDown) {\r\n                _preventObj.prevent = !_closestElement(e.target, _options.isClickableElement);\r\n\r\n                _shout('preventDragEvent', e, isDown, _preventObj);\r\n                return _preventObj.prevent;\r\n\r\n            },\r\n            _convertTouchToPoint = function(touch, p) {\r\n                p.x = touch.pageX;\r\n                p.y = touch.pageY;\r\n                p.id = touch.identifier;\r\n                return p;\r\n            },\r\n            _findCenterOfPoints = function(p1, p2, pCenter) {\r\n                pCenter.x = (p1.x + p2.x) * 0.5;\r\n                pCenter.y = (p1.y + p2.y) * 0.5;\r\n            },\r\n            _pushPosPoint = function(time, x, y) {\r\n                if (time - _gestureCheckSpeedTime > 50) {\r\n                    var o = _posPoints.length > 2 ? _posPoints.shift() : {};\r\n                    o.x = x;\r\n                    o.y = y;\r\n                    _posPoints.push(o);\r\n                    _gestureCheckSpeedTime = time;\r\n                }\r\n            },\r\n\r\n            _calculateVerticalDragOpacityRatio = function() {\r\n                var yOffset = _panOffset.y - self.currItem.initialPosition.y; // difference between initial and current position\r\n                return 1 - Math.abs(yOffset / (_viewportSize.y / 2));\r\n            },\r\n\r\n\r\n            // points pool, reused during touch events\r\n            _ePoint1 = {},\r\n            _ePoint2 = {},\r\n            _tempPointsArr = [],\r\n            _tempCounter,\r\n            _getTouchPoints = function(e) {\r\n                // clean up previous points, without recreating array\r\n                while (_tempPointsArr.length > 0) {\r\n                    _tempPointsArr.pop();\r\n                }\r\n\r\n                if (!_pointerEventEnabled) {\r\n                    if (e.type.indexOf('touch') > -1) {\r\n\r\n                        if (e.touches && e.touches.length > 0) {\r\n                            _tempPointsArr[0] = _convertTouchToPoint(e.touches[0], _ePoint1);\r\n                            if (e.touches.length > 1) {\r\n                                _tempPointsArr[1] = _convertTouchToPoint(e.touches[1], _ePoint2);\r\n                            }\r\n                        }\r\n\r\n                    } else {\r\n                        _ePoint1.x = e.pageX;\r\n                        _ePoint1.y = e.pageY;\r\n                        _ePoint1.id = '';\r\n                        _tempPointsArr[0] = _ePoint1; //_ePoint1;\r\n                    }\r\n                } else {\r\n                    _tempCounter = 0;\r\n                    // we can use forEach, as pointer events are supported only in modern browsers\r\n                    _currPointers.forEach(function(p) {\r\n                        if (_tempCounter === 0) {\r\n                            _tempPointsArr[0] = p;\r\n                        } else if (_tempCounter === 1) {\r\n                            _tempPointsArr[1] = p;\r\n                        }\r\n                        _tempCounter++;\r\n\r\n                    });\r\n                }\r\n                return _tempPointsArr;\r\n            },\r\n\r\n            _panOrMoveMainScroll = function(axis, delta) {\r\n\r\n                var panFriction,\r\n                    overDiff = 0,\r\n                    newOffset = _panOffset[axis] + delta[axis],\r\n                    startOverDiff,\r\n                    dir = delta[axis] > 0,\r\n                    newMainScrollPosition = _mainScrollPos.x + delta.x,\r\n                    mainScrollDiff = _mainScrollPos.x - _startMainScrollPos.x,\r\n                    newPanPos,\r\n                    newMainScrollPos;\r\n\r\n                // calculate fdistance over the bounds and friction\r\n                if (newOffset > _currPanBounds.min[axis] || newOffset < _currPanBounds.max[axis]) {\r\n                    panFriction = _options.panEndFriction;\r\n                    // Linear increasing of friction, so at 1/4 of viewport it's at max value. \r\n                    // Looks not as nice as was expected. Left for history.\r\n                    // panFriction = (1 - (_panOffset[axis] + delta[axis] + panBounds.min[axis]) / (_viewportSize[axis] / 4) );\r\n                } else {\r\n                    panFriction = 1;\r\n                }\r\n\r\n                newOffset = _panOffset[axis] + delta[axis] * panFriction;\r\n\r\n                // move main scroll or start panning\r\n                if (_options.allowPanToNext || _currZoomLevel === self.currItem.initialZoomLevel) {\r\n\r\n\r\n                    if (!_currZoomElementStyle) {\r\n\r\n                        newMainScrollPos = newMainScrollPosition;\r\n\r\n                    } else if (_direction === 'h' && axis === 'x' && !_zoomStarted) {\r\n\r\n                        if (dir) {\r\n                            if (newOffset > _currPanBounds.min[axis]) {\r\n                                panFriction = _options.panEndFriction;\r\n                                overDiff = _currPanBounds.min[axis] - newOffset;\r\n                                startOverDiff = _currPanBounds.min[axis] - _startPanOffset[axis];\r\n                            }\r\n\r\n                            // drag right\r\n                            if ((startOverDiff <= 0 || mainScrollDiff < 0) && _getNumItems() > 1) {\r\n                                newMainScrollPos = newMainScrollPosition;\r\n                                if (mainScrollDiff < 0 && newMainScrollPosition > _startMainScrollPos.x) {\r\n                                    newMainScrollPos = _startMainScrollPos.x;\r\n                                }\r\n                            } else {\r\n                                if (_currPanBounds.min.x !== _currPanBounds.max.x) {\r\n                                    newPanPos = newOffset;\r\n                                }\r\n\r\n                            }\r\n\r\n                        } else {\r\n\r\n                            if (newOffset < _currPanBounds.max[axis]) {\r\n                                panFriction = _options.panEndFriction;\r\n                                overDiff = newOffset - _currPanBounds.max[axis];\r\n                                startOverDiff = _startPanOffset[axis] - _currPanBounds.max[axis];\r\n                            }\r\n\r\n                            if ((startOverDiff <= 0 || mainScrollDiff > 0) && _getNumItems() > 1) {\r\n                                newMainScrollPos = newMainScrollPosition;\r\n\r\n                                if (mainScrollDiff > 0 && newMainScrollPosition < _startMainScrollPos.x) {\r\n                                    newMainScrollPos = _startMainScrollPos.x;\r\n                                }\r\n\r\n                            } else {\r\n                                if (_currPanBounds.min.x !== _currPanBounds.max.x) {\r\n                                    newPanPos = newOffset;\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n\r\n                        //\r\n                    }\r\n\r\n                    if (axis === 'x') {\r\n\r\n                        if (newMainScrollPos !== undefined) {\r\n                            _moveMainScroll(newMainScrollPos, true);\r\n                            if (newMainScrollPos === _startMainScrollPos.x) {\r\n                                _mainScrollShifted = false;\r\n                            } else {\r\n                                _mainScrollShifted = true;\r\n                            }\r\n                        }\r\n\r\n                        if (_currPanBounds.min.x !== _currPanBounds.max.x) {\r\n                            if (newPanPos !== undefined) {\r\n                                _panOffset.x = newPanPos;\r\n                            } else if (!_mainScrollShifted) {\r\n                                _panOffset.x += delta.x * panFriction;\r\n                            }\r\n                        }\r\n\r\n                        return newMainScrollPos !== undefined;\r\n                    }\r\n\r\n                }\r\n\r\n                if (!_mainScrollAnimating) {\r\n\r\n                    if (!_mainScrollShifted) {\r\n                        if (_currZoomLevel > self.currItem.fitRatio) {\r\n                            _panOffset[axis] += delta[axis] * panFriction;\r\n\r\n                        }\r\n                    }\r\n\r\n\r\n                }\r\n\r\n            },\r\n\r\n            // Pointerdown/touchstart/mousedown handler\r\n            _onDragStart = function(e) {\r\n\r\n                // Allow dragging only via left mouse button.\r\n                // As this handler is not added in IE8 - we ignore e.which\r\n                // \r\n                // http://www.quirksmode.org/js/events_properties.html\r\n                // https://developer.mozilla.org/en-US/docs/Web/API/event.button\r\n                if (e.type === 'mousedown' && e.button > 0) {\r\n                    return;\r\n                }\r\n\r\n                if (_initialZoomRunning) {\r\n                    e.preventDefault();\r\n                    return;\r\n                }\r\n\r\n                if (_oldAndroidTouchEndTimeout && e.type === 'mousedown') {\r\n                    return;\r\n                }\r\n\r\n                if (_preventDefaultEventBehaviour(e, true)) {\r\n                    e.preventDefault();\r\n                }\r\n\r\n\r\n\r\n                _shout('pointerDown');\r\n\r\n                if (_pointerEventEnabled) {\r\n                    var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');\r\n                    if (pointerIndex < 0) {\r\n                        pointerIndex = _currPointers.length;\r\n                    }\r\n                    _currPointers[pointerIndex] = { x: e.pageX, y: e.pageY, id: e.pointerId };\r\n                }\r\n\r\n\r\n\r\n                var startPointsList = _getTouchPoints(e),\r\n                    numPoints = startPointsList.length;\r\n\r\n                _currentPoints = null;\r\n\r\n                _stopAllAnimations();\r\n\r\n                // init drag\r\n                if (!_isDragging || numPoints === 1) {\r\n\r\n\r\n\r\n                    _isDragging = _isFirstMove = true;\r\n                    framework.bind(window, _upMoveEvents, self);\r\n\r\n                    _isZoomingIn =\r\n                        _wasOverInitialZoom =\r\n                        _opacityChanged =\r\n                        _verticalDragInitiated =\r\n                        _mainScrollShifted =\r\n                        _moved =\r\n                        _isMultitouch =\r\n                        _zoomStarted = false;\r\n\r\n                    _direction = null;\r\n\r\n                    _shout('firstTouchStart', startPointsList);\r\n\r\n                    _equalizePoints(_startPanOffset, _panOffset);\r\n\r\n                    _currPanDist.x = _currPanDist.y = 0;\r\n                    _equalizePoints(_currPoint, startPointsList[0]);\r\n                    _equalizePoints(_startPoint, _currPoint);\r\n\r\n                    //_equalizePoints(_startMainScrollPos, _mainScrollPos);\r\n                    _startMainScrollPos.x = _slideSize.x * _currPositionIndex;\r\n\r\n                    _posPoints = [{\r\n                        x: _currPoint.x,\r\n                        y: _currPoint.y\r\n                    }];\r\n\r\n                    _gestureCheckSpeedTime = _gestureStartTime = _getCurrentTime();\r\n\r\n                    //_mainScrollAnimationEnd(true);\r\n                    _calculatePanBounds(_currZoomLevel, true);\r\n\r\n                    // Start rendering\r\n                    _stopDragUpdateLoop();\r\n                    _dragUpdateLoop();\r\n\r\n                }\r\n\r\n                // init zoom\r\n                if (!_isZooming && numPoints > 1 && !_mainScrollAnimating && !_mainScrollShifted) {\r\n                    _startZoomLevel = _currZoomLevel;\r\n                    _zoomStarted = false; // true if zoom changed at least once\r\n\r\n                    _isZooming = _isMultitouch = true;\r\n                    _currPanDist.y = _currPanDist.x = 0;\r\n\r\n                    _equalizePoints(_startPanOffset, _panOffset);\r\n\r\n                    _equalizePoints(p, startPointsList[0]);\r\n                    _equalizePoints(p2, startPointsList[1]);\r\n\r\n                    _findCenterOfPoints(p, p2, _currCenterPoint);\r\n\r\n                    _midZoomPoint.x = Math.abs(_currCenterPoint.x) - _panOffset.x;\r\n                    _midZoomPoint.y = Math.abs(_currCenterPoint.y) - _panOffset.y;\r\n                    _currPointsDistance = _startPointsDistance = _calculatePointsDistance(p, p2);\r\n                }\r\n\r\n\r\n            },\r\n\r\n            // Pointermove/touchmove/mousemove handler\r\n            _onDragMove = function(e) {\r\n\r\n                e.preventDefault();\r\n\r\n                if (_pointerEventEnabled) {\r\n                    var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');\r\n                    if (pointerIndex > -1) {\r\n                        var p = _currPointers[pointerIndex];\r\n                        p.x = e.pageX;\r\n                        p.y = e.pageY;\r\n                    }\r\n                }\r\n\r\n                if (_isDragging) {\r\n                    var touchesList = _getTouchPoints(e);\r\n                    if (!_direction && !_moved && !_isZooming) {\r\n\r\n                        if (_mainScrollPos.x !== _slideSize.x * _currPositionIndex) {\r\n                            // if main scroll position is shifted  direction is always horizontal\r\n                            _direction = 'h';\r\n                        } else {\r\n                            var diff = Math.abs(touchesList[0].x - _currPoint.x) - Math.abs(touchesList[0].y - _currPoint.y);\r\n                            // check the direction of movement\r\n                            if (Math.abs(diff) >= DIRECTION_CHECK_OFFSET) {\r\n                                _direction = diff > 0 ? 'h' : 'v';\r\n                                _currentPoints = touchesList;\r\n                            }\r\n                        }\r\n\r\n                    } else {\r\n                        _currentPoints = touchesList;\r\n                    }\r\n                }\r\n            },\r\n            // \r\n            _renderMovement = function() {\r\n\r\n                if (!_currentPoints) {\r\n                    return;\r\n                }\r\n\r\n                var numPoints = _currentPoints.length;\r\n\r\n                if (numPoints === 0) {\r\n                    return;\r\n                }\r\n\r\n                _equalizePoints(p, _currentPoints[0]);\r\n\r\n                delta.x = p.x - _currPoint.x;\r\n                delta.y = p.y - _currPoint.y;\r\n\r\n                if (_isZooming && numPoints > 1) {\r\n                    // Handle behaviour for more than 1 point\r\n\r\n                    _currPoint.x = p.x;\r\n                    _currPoint.y = p.y;\r\n\r\n                    // check if one of two points changed\r\n                    if (!delta.x && !delta.y && _isEqualPoints(_currentPoints[1], p2)) {\r\n                        return;\r\n                    }\r\n\r\n                    _equalizePoints(p2, _currentPoints[1]);\r\n\r\n\r\n                    if (!_zoomStarted) {\r\n                        _zoomStarted = true;\r\n                        _shout('zoomGestureStarted');\r\n                    }\r\n\r\n                    // Distance between two points\r\n                    var pointsDistance = _calculatePointsDistance(p, p2);\r\n\r\n                    var zoomLevel = _calculateZoomLevel(pointsDistance);\r\n\r\n                    // slightly over the of initial zoom level\r\n                    if (zoomLevel > self.currItem.initialZoomLevel + self.currItem.initialZoomLevel / 15) {\r\n                        _wasOverInitialZoom = true;\r\n                    }\r\n\r\n                    // Apply the friction if zoom level is out of the bounds\r\n                    var zoomFriction = 1,\r\n                        minZoomLevel = _getMinZoomLevel(),\r\n                        maxZoomLevel = _getMaxZoomLevel();\r\n\r\n                    if (zoomLevel < minZoomLevel) {\r\n\r\n                        if (_options.pinchToClose && !_wasOverInitialZoom && _startZoomLevel <= self.currItem.initialZoomLevel) {\r\n                            // fade out background if zooming out\r\n                            var minusDiff = minZoomLevel - zoomLevel;\r\n                            var percent = 1 - minusDiff / (minZoomLevel / 1.2);\r\n\r\n                            _applyBgOpacity(percent);\r\n                            _shout('onPinchClose', percent);\r\n                            _opacityChanged = true;\r\n                        } else {\r\n                            zoomFriction = (minZoomLevel - zoomLevel) / minZoomLevel;\r\n                            if (zoomFriction > 1) {\r\n                                zoomFriction = 1;\r\n                            }\r\n                            zoomLevel = minZoomLevel - zoomFriction * (minZoomLevel / 3);\r\n                        }\r\n\r\n                    } else if (zoomLevel > maxZoomLevel) {\r\n                        // 1.5 - extra zoom level above the max. E.g. if max is x6, real max 6 + 1.5 = 7.5\r\n                        zoomFriction = (zoomLevel - maxZoomLevel) / (minZoomLevel * 6);\r\n                        if (zoomFriction > 1) {\r\n                            zoomFriction = 1;\r\n                        }\r\n                        zoomLevel = maxZoomLevel + zoomFriction * minZoomLevel;\r\n                    }\r\n\r\n                    if (zoomFriction < 0) {\r\n                        zoomFriction = 0;\r\n                    }\r\n\r\n                    // distance between touch points after friction is applied\r\n                    _currPointsDistance = pointsDistance;\r\n\r\n                    // _centerPoint - The point in the middle of two pointers\r\n                    _findCenterOfPoints(p, p2, _centerPoint);\r\n\r\n                    // paning with two pointers pressed\r\n                    _currPanDist.x += _centerPoint.x - _currCenterPoint.x;\r\n                    _currPanDist.y += _centerPoint.y - _currCenterPoint.y;\r\n                    _equalizePoints(_currCenterPoint, _centerPoint);\r\n\r\n                    _panOffset.x = _calculatePanOffset('x', zoomLevel);\r\n                    _panOffset.y = _calculatePanOffset('y', zoomLevel);\r\n\r\n                    _isZoomingIn = zoomLevel > _currZoomLevel;\r\n                    _currZoomLevel = zoomLevel;\r\n                    _applyCurrentZoomPan();\r\n\r\n                } else {\r\n\r\n                    // handle behaviour for one point (dragging or panning)\r\n\r\n                    if (!_direction) {\r\n                        return;\r\n                    }\r\n\r\n                    if (_isFirstMove) {\r\n                        _isFirstMove = false;\r\n\r\n                        // subtract drag distance that was used during the detection direction  \r\n\r\n                        if (Math.abs(delta.x) >= DIRECTION_CHECK_OFFSET) {\r\n                            delta.x -= _currentPoints[0].x - _startPoint.x;\r\n                        }\r\n\r\n                        if (Math.abs(delta.y) >= DIRECTION_CHECK_OFFSET) {\r\n                            delta.y -= _currentPoints[0].y - _startPoint.y;\r\n                        }\r\n                    }\r\n\r\n                    _currPoint.x = p.x;\r\n                    _currPoint.y = p.y;\r\n\r\n                    // do nothing if pointers position hasn't changed\r\n                    if (delta.x === 0 && delta.y === 0) {\r\n                        return;\r\n                    }\r\n\r\n                    if (_direction === 'v' && _options.closeOnVerticalDrag) {\r\n                        if (!_canPan()) {\r\n                            _currPanDist.y += delta.y;\r\n                            _panOffset.y += delta.y;\r\n\r\n                            var opacityRatio = _calculateVerticalDragOpacityRatio();\r\n\r\n                            _verticalDragInitiated = true;\r\n                            _shout('onVerticalDrag', opacityRatio);\r\n\r\n                            _applyBgOpacity(opacityRatio);\r\n                            _applyCurrentZoomPan();\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    _pushPosPoint(_getCurrentTime(), p.x, p.y);\r\n\r\n                    _moved = true;\r\n                    _currPanBounds = self.currItem.bounds;\r\n\r\n                    var mainScrollChanged = _panOrMoveMainScroll('x', delta);\r\n                    if (!mainScrollChanged) {\r\n                        _panOrMoveMainScroll('y', delta);\r\n\r\n                        _roundPoint(_panOffset);\r\n                        _applyCurrentZoomPan();\r\n                    }\r\n\r\n                }\r\n\r\n            },\r\n\r\n            // Pointerup/pointercancel/touchend/touchcancel/mouseup event handler\r\n            _onDragRelease = function(e) {\r\n\r\n                if (_features.isOldAndroid) {\r\n\r\n                    if (_oldAndroidTouchEndTimeout && e.type === 'mouseup') {\r\n                        return;\r\n                    }\r\n\r\n                    // on Android (v4.1, 4.2, 4.3 & possibly older) \r\n                    // ghost mousedown/up event isn't preventable via e.preventDefault,\r\n                    // which causes fake mousedown event\r\n                    // so we block mousedown/up for 600ms\r\n                    if (e.type.indexOf('touch') > -1) {\r\n                        clearTimeout(_oldAndroidTouchEndTimeout);\r\n                        _oldAndroidTouchEndTimeout = setTimeout(function() {\r\n                            _oldAndroidTouchEndTimeout = 0;\r\n                        }, 600);\r\n                    }\r\n\r\n                }\r\n\r\n                _shout('pointerUp');\r\n\r\n                if (_preventDefaultEventBehaviour(e, false)) {\r\n                    e.preventDefault();\r\n                }\r\n\r\n                var releasePoint;\r\n\r\n                if (_pointerEventEnabled) {\r\n                    var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');\r\n\r\n                    if (pointerIndex > -1) {\r\n                        releasePoint = _currPointers.splice(pointerIndex, 1)[0];\r\n\r\n                        if (navigator.pointerEnabled) {\r\n                            releasePoint.type = e.pointerType || 'mouse';\r\n                        } else {\r\n                            var MSPOINTER_TYPES = {\r\n                                4: 'mouse', // event.MSPOINTER_TYPE_MOUSE\r\n                                2: 'touch', // event.MSPOINTER_TYPE_TOUCH \r\n                                3: 'pen' // event.MSPOINTER_TYPE_PEN\r\n                            };\r\n                            releasePoint.type = MSPOINTER_TYPES[e.pointerType];\r\n\r\n                            if (!releasePoint.type) {\r\n                                releasePoint.type = e.pointerType || 'mouse';\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n\r\n                var touchList = _getTouchPoints(e),\r\n                    gestureType,\r\n                    numPoints = touchList.length;\r\n\r\n                if (e.type === 'mouseup') {\r\n                    numPoints = 0;\r\n                }\r\n\r\n                // Do nothing if there were 3 touch points or more\r\n                if (numPoints === 2) {\r\n                    _currentPoints = null;\r\n                    return true;\r\n                }\r\n\r\n                // if second pointer released\r\n                if (numPoints === 1) {\r\n                    _equalizePoints(_startPoint, touchList[0]);\r\n                }\r\n\r\n\r\n                // pointer hasn't moved, send \"tap release\" point\r\n                if (numPoints === 0 && !_direction && !_mainScrollAnimating) {\r\n                    if (!releasePoint) {\r\n                        if (e.type === 'mouseup') {\r\n                            releasePoint = { x: e.pageX, y: e.pageY, type: 'mouse' };\r\n                        } else if (e.changedTouches && e.changedTouches[0]) {\r\n                            releasePoint = { x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY, type: 'touch' };\r\n                        }\r\n                    }\r\n\r\n                    _shout('touchRelease', e, releasePoint);\r\n                }\r\n\r\n                // Difference in time between releasing of two last touch points (zoom gesture)\r\n                var releaseTimeDiff = -1;\r\n\r\n                // Gesture completed, no pointers left\r\n                if (numPoints === 0) {\r\n                    _isDragging = false;\r\n                    framework.unbind(window, _upMoveEvents, self);\r\n\r\n                    _stopDragUpdateLoop();\r\n\r\n                    if (_isZooming) {\r\n                        // Two points released at the same time\r\n                        releaseTimeDiff = 0;\r\n                    } else if (_lastReleaseTime !== -1) {\r\n                        releaseTimeDiff = _getCurrentTime() - _lastReleaseTime;\r\n                    }\r\n                }\r\n                _lastReleaseTime = numPoints === 1 ? _getCurrentTime() : -1;\r\n\r\n                if (releaseTimeDiff !== -1 && releaseTimeDiff < 150) {\r\n                    gestureType = 'zoom';\r\n                } else {\r\n                    gestureType = 'swipe';\r\n                }\r\n\r\n                if (_isZooming && numPoints < 2) {\r\n                    _isZooming = false;\r\n\r\n                    // Only second point released\r\n                    if (numPoints === 1) {\r\n                        gestureType = 'zoomPointerUp';\r\n                    }\r\n                    _shout('zoomGestureEnded');\r\n                }\r\n\r\n                _currentPoints = null;\r\n                if (!_moved && !_zoomStarted && !_mainScrollAnimating && !_verticalDragInitiated) {\r\n                    // nothing to animate\r\n                    return;\r\n                }\r\n\r\n                _stopAllAnimations();\r\n\r\n\r\n                if (!_releaseAnimData) {\r\n                    _releaseAnimData = _initDragReleaseAnimationData();\r\n                }\r\n\r\n                _releaseAnimData.calculateSwipeSpeed('x');\r\n\r\n\r\n                if (_verticalDragInitiated) {\r\n\r\n                    var opacityRatio = _calculateVerticalDragOpacityRatio();\r\n\r\n                    if (opacityRatio < _options.verticalDragRange) {\r\n                        self.close();\r\n                    } else {\r\n                        var initalPanY = _panOffset.y,\r\n                            initialBgOpacity = _bgOpacity;\r\n\r\n                        _animateProp('verticalDrag', 0, 1, 300, framework.easing.cubic.out, function(now) {\r\n\r\n                            _panOffset.y = (self.currItem.initialPosition.y - initalPanY) * now + initalPanY;\r\n\r\n                            _applyBgOpacity((1 - initialBgOpacity) * now + initialBgOpacity);\r\n                            _applyCurrentZoomPan();\r\n                        });\r\n\r\n                        _shout('onVerticalDrag', 1);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n\r\n                // main scroll \r\n                if ((_mainScrollShifted || _mainScrollAnimating) && numPoints === 0) {\r\n                    var itemChanged = _finishSwipeMainScrollGesture(gestureType, _releaseAnimData);\r\n                    if (itemChanged) {\r\n                        return;\r\n                    }\r\n                    gestureType = 'zoomPointerUp';\r\n                }\r\n\r\n                // prevent zoom/pan animation when main scroll animation runs\r\n                if (_mainScrollAnimating) {\r\n                    return;\r\n                }\r\n\r\n                // Complete simple zoom gesture (reset zoom level if it's out of the bounds)  \r\n                if (gestureType !== 'swipe') {\r\n                    _completeZoomGesture();\r\n                    return;\r\n                }\r\n\r\n                // Complete pan gesture if main scroll is not shifted, and it's possible to pan current image\r\n                if (!_mainScrollShifted && _currZoomLevel > self.currItem.fitRatio) {\r\n                    _completePanGesture(_releaseAnimData);\r\n                }\r\n            },\r\n\r\n\r\n            // Returns object with data about gesture\r\n            // It's created only once and then reused\r\n            _initDragReleaseAnimationData = function() {\r\n                // temp local vars\r\n                var lastFlickDuration,\r\n                    tempReleasePos;\r\n\r\n                // s = this\r\n                var s = {\r\n                    lastFlickOffset: {},\r\n                    lastFlickDist: {},\r\n                    lastFlickSpeed: {},\r\n                    slowDownRatio: {},\r\n                    slowDownRatioReverse: {},\r\n                    speedDecelerationRatio: {},\r\n                    speedDecelerationRatioAbs: {},\r\n                    distanceOffset: {},\r\n                    backAnimDestination: {},\r\n                    backAnimStarted: {},\r\n                    calculateSwipeSpeed: function(axis) {\r\n\r\n\r\n                        if (_posPoints.length > 1) {\r\n                            lastFlickDuration = _getCurrentTime() - _gestureCheckSpeedTime + 50;\r\n                            tempReleasePos = _posPoints[_posPoints.length - 2][axis];\r\n                        } else {\r\n                            lastFlickDuration = _getCurrentTime() - _gestureStartTime; // total gesture duration\r\n                            tempReleasePos = _startPoint[axis];\r\n                        }\r\n                        s.lastFlickOffset[axis] = _currPoint[axis] - tempReleasePos;\r\n                        s.lastFlickDist[axis] = Math.abs(s.lastFlickOffset[axis]);\r\n                        if (s.lastFlickDist[axis] > 20) {\r\n                            s.lastFlickSpeed[axis] = s.lastFlickOffset[axis] / lastFlickDuration;\r\n                        } else {\r\n                            s.lastFlickSpeed[axis] = 0;\r\n                        }\r\n                        if (Math.abs(s.lastFlickSpeed[axis]) < 0.1) {\r\n                            s.lastFlickSpeed[axis] = 0;\r\n                        }\r\n\r\n                        s.slowDownRatio[axis] = 0.95;\r\n                        s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];\r\n                        s.speedDecelerationRatio[axis] = 1;\r\n                    },\r\n\r\n                    calculateOverBoundsAnimOffset: function(axis, speed) {\r\n                        if (!s.backAnimStarted[axis]) {\r\n\r\n                            if (_panOffset[axis] > _currPanBounds.min[axis]) {\r\n                                s.backAnimDestination[axis] = _currPanBounds.min[axis];\r\n\r\n                            } else if (_panOffset[axis] < _currPanBounds.max[axis]) {\r\n                                s.backAnimDestination[axis] = _currPanBounds.max[axis];\r\n                            }\r\n\r\n                            if (s.backAnimDestination[axis] !== undefined) {\r\n                                s.slowDownRatio[axis] = 0.7;\r\n                                s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];\r\n                                if (s.speedDecelerationRatioAbs[axis] < 0.05) {\r\n\r\n                                    s.lastFlickSpeed[axis] = 0;\r\n                                    s.backAnimStarted[axis] = true;\r\n\r\n                                    _animateProp('bounceZoomPan' + axis, _panOffset[axis],\r\n                                        s.backAnimDestination[axis],\r\n                                        speed || 300,\r\n                                        framework.easing.sine.out,\r\n                                        function(pos) {\r\n                                            _panOffset[axis] = pos;\r\n                                            _applyCurrentZoomPan();\r\n                                        }\r\n                                    );\r\n\r\n                                }\r\n                            }\r\n                        }\r\n                    },\r\n\r\n                    // Reduces the speed by slowDownRatio (per 10ms)\r\n                    calculateAnimOffset: function(axis) {\r\n                        if (!s.backAnimStarted[axis]) {\r\n                            s.speedDecelerationRatio[axis] = s.speedDecelerationRatio[axis] * (s.slowDownRatio[axis] +\r\n                                s.slowDownRatioReverse[axis] -\r\n                                s.slowDownRatioReverse[axis] * s.timeDiff / 10);\r\n\r\n                            s.speedDecelerationRatioAbs[axis] = Math.abs(s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis]);\r\n                            s.distanceOffset[axis] = s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis] * s.timeDiff;\r\n                            _panOffset[axis] += s.distanceOffset[axis];\r\n\r\n                        }\r\n                    },\r\n\r\n                    panAnimLoop: function() {\r\n                        if (_animations.zoomPan) {\r\n                            _animations.zoomPan.raf = _requestAF(s.panAnimLoop);\r\n\r\n                            s.now = _getCurrentTime();\r\n                            s.timeDiff = s.now - s.lastNow;\r\n                            s.lastNow = s.now;\r\n\r\n                            s.calculateAnimOffset('x');\r\n                            s.calculateAnimOffset('y');\r\n\r\n                            _applyCurrentZoomPan();\r\n\r\n                            s.calculateOverBoundsAnimOffset('x');\r\n                            s.calculateOverBoundsAnimOffset('y');\r\n\r\n\r\n                            if (s.speedDecelerationRatioAbs.x < 0.05 && s.speedDecelerationRatioAbs.y < 0.05) {\r\n\r\n                                // round pan position\r\n                                _panOffset.x = Math.round(_panOffset.x);\r\n                                _panOffset.y = Math.round(_panOffset.y);\r\n                                _applyCurrentZoomPan();\r\n\r\n                                _stopAnimation('zoomPan');\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                };\r\n                return s;\r\n            },\r\n\r\n            _completePanGesture = function(animData) {\r\n                // calculate swipe speed for Y axis (paanning)\r\n                animData.calculateSwipeSpeed('y');\r\n\r\n                _currPanBounds = self.currItem.bounds;\r\n\r\n                animData.backAnimDestination = {};\r\n                animData.backAnimStarted = {};\r\n\r\n                // Avoid acceleration animation if speed is too low\r\n                if (Math.abs(animData.lastFlickSpeed.x) <= 0.05 && Math.abs(animData.lastFlickSpeed.y) <= 0.05) {\r\n                    animData.speedDecelerationRatioAbs.x = animData.speedDecelerationRatioAbs.y = 0;\r\n\r\n                    // Run pan drag release animation. E.g. if you drag image and release finger without momentum.\r\n                    animData.calculateOverBoundsAnimOffset('x');\r\n                    animData.calculateOverBoundsAnimOffset('y');\r\n                    return true;\r\n                }\r\n\r\n                // Animation loop that controls the acceleration after pan gesture ends\r\n                _registerStartAnimation('zoomPan');\r\n                animData.lastNow = _getCurrentTime();\r\n                animData.panAnimLoop();\r\n            },\r\n\r\n\r\n            _finishSwipeMainScrollGesture = function(gestureType, _releaseAnimData) {\r\n                var itemChanged;\r\n                if (!_mainScrollAnimating) {\r\n                    _currZoomedItemIndex = _currentItemIndex;\r\n                }\r\n\r\n\r\n\r\n                var itemsDiff;\r\n\r\n                if (gestureType === 'swipe') {\r\n                    var totalShiftDist = _currPoint.x - _startPoint.x,\r\n                        isFastLastFlick = _releaseAnimData.lastFlickDist.x < 10;\r\n\r\n                    // if container is shifted for more than MIN_SWIPE_DISTANCE, \r\n                    // and last flick gesture was in right direction\r\n                    if (totalShiftDist > MIN_SWIPE_DISTANCE &&\r\n                        (isFastLastFlick || _releaseAnimData.lastFlickOffset.x > 20)) {\r\n                        // go to prev item\r\n                        itemsDiff = -1;\r\n                    } else if (totalShiftDist < -MIN_SWIPE_DISTANCE &&\r\n                        (isFastLastFlick || _releaseAnimData.lastFlickOffset.x < -20)) {\r\n                        // go to next item\r\n                        itemsDiff = 1;\r\n                    }\r\n                }\r\n\r\n                var nextCircle;\r\n\r\n                if (itemsDiff) {\r\n\r\n                    _currentItemIndex += itemsDiff;\r\n\r\n                    if (_currentItemIndex < 0) {\r\n                        _currentItemIndex = _options.loop ? _getNumItems() - 1 : 0;\r\n                        nextCircle = true;\r\n                    } else if (_currentItemIndex >= _getNumItems()) {\r\n                        _currentItemIndex = _options.loop ? 0 : _getNumItems() - 1;\r\n                        nextCircle = true;\r\n                    }\r\n\r\n                    if (!nextCircle || _options.loop) {\r\n                        _indexDiff += itemsDiff;\r\n                        _currPositionIndex -= itemsDiff;\r\n                        itemChanged = true;\r\n                    }\r\n\r\n\r\n\r\n                }\r\n\r\n                var animateToX = _slideSize.x * _currPositionIndex;\r\n                var animateToDist = Math.abs(animateToX - _mainScrollPos.x);\r\n                var finishAnimDuration;\r\n\r\n\r\n                if (!itemChanged && animateToX > _mainScrollPos.x !== _releaseAnimData.lastFlickSpeed.x > 0) {\r\n                    // \"return to current\" duration, e.g. when dragging from slide 0 to -1\r\n                    finishAnimDuration = 333;\r\n                } else {\r\n                    finishAnimDuration = Math.abs(_releaseAnimData.lastFlickSpeed.x) > 0 ?\r\n                        animateToDist / Math.abs(_releaseAnimData.lastFlickSpeed.x) :\r\n                        333;\r\n\r\n                    finishAnimDuration = Math.min(finishAnimDuration, 400);\r\n                    finishAnimDuration = Math.max(finishAnimDuration, 250);\r\n                }\r\n\r\n                if (_currZoomedItemIndex === _currentItemIndex) {\r\n                    itemChanged = false;\r\n                }\r\n\r\n                _mainScrollAnimating = true;\r\n\r\n                _shout('mainScrollAnimStart');\r\n\r\n                _animateProp('mainScroll', _mainScrollPos.x, animateToX, finishAnimDuration, framework.easing.cubic.out,\r\n                    _moveMainScroll,\r\n                    function() {\r\n                        _stopAllAnimations();\r\n                        _mainScrollAnimating = false;\r\n                        _currZoomedItemIndex = -1;\r\n\r\n                        if (itemChanged || _currZoomedItemIndex !== _currentItemIndex) {\r\n                            self.updateCurrItem();\r\n                        }\r\n\r\n                        _shout('mainScrollAnimComplete');\r\n                    }\r\n                );\r\n\r\n                if (itemChanged) {\r\n                    self.updateCurrItem(true);\r\n                }\r\n\r\n                return itemChanged;\r\n            },\r\n\r\n            _calculateZoomLevel = function(touchesDistance) {\r\n                return 1 / _startPointsDistance * touchesDistance * _startZoomLevel;\r\n            },\r\n\r\n            // Resets zoom if it's out of bounds\r\n            _completeZoomGesture = function() {\r\n                var destZoomLevel = _currZoomLevel,\r\n                    minZoomLevel = _getMinZoomLevel(),\r\n                    maxZoomLevel = _getMaxZoomLevel();\r\n\r\n                if (_currZoomLevel < minZoomLevel) {\r\n                    destZoomLevel = minZoomLevel;\r\n                } else if (_currZoomLevel > maxZoomLevel) {\r\n                    destZoomLevel = maxZoomLevel;\r\n                }\r\n\r\n                var destOpacity = 1,\r\n                    onUpdate,\r\n                    initialOpacity = _bgOpacity;\r\n\r\n                if (_opacityChanged && !_isZoomingIn && !_wasOverInitialZoom && _currZoomLevel < minZoomLevel) {\r\n                    //_closedByScroll = true;\r\n                    self.close();\r\n                    return true;\r\n                }\r\n\r\n                if (_opacityChanged) {\r\n                    onUpdate = function(now) {\r\n                        _applyBgOpacity((destOpacity - initialOpacity) * now + initialOpacity);\r\n                    };\r\n                }\r\n\r\n                self.zoomTo(destZoomLevel, 0, 200, framework.easing.cubic.out, onUpdate);\r\n                return true;\r\n            };\r\n\r\n\r\n        _registerModule('Gestures', {\r\n            publicMethods: {\r\n\r\n                initGestures: function() {\r\n\r\n                    // helper function that builds touch/pointer/mouse events\r\n                    var addEventNames = function(pref, down, move, up, cancel) {\r\n                        _dragStartEvent = pref + down;\r\n                        _dragMoveEvent = pref + move;\r\n                        _dragEndEvent = pref + up;\r\n                        if (cancel) {\r\n                            _dragCancelEvent = pref + cancel;\r\n                        } else {\r\n                            _dragCancelEvent = '';\r\n                        }\r\n                    };\r\n\r\n                    _pointerEventEnabled = _features.pointerEvent;\r\n                    if (_pointerEventEnabled && _features.touch) {\r\n                        // we don't need touch events, if browser supports pointer events\r\n                        _features.touch = false;\r\n                    }\r\n\r\n                    if (_pointerEventEnabled) {\r\n                        if (navigator.pointerEnabled) {\r\n                            addEventNames('pointer', 'down', 'move', 'up', 'cancel');\r\n                        } else {\r\n                            // IE10 pointer events are case-sensitive\r\n                            addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');\r\n                        }\r\n                    } else if (_features.touch) {\r\n                        addEventNames('touch', 'start', 'move', 'end', 'cancel');\r\n                        _likelyTouchDevice = true;\r\n                    } else {\r\n                        addEventNames('mouse', 'down', 'move', 'up');\r\n                    }\r\n\r\n                    _upMoveEvents = _dragMoveEvent + ' ' + _dragEndEvent + ' ' + _dragCancelEvent;\r\n                    _downEvents = _dragStartEvent;\r\n\r\n                    if (_pointerEventEnabled && !_likelyTouchDevice) {\r\n                        _likelyTouchDevice = (navigator.maxTouchPoints > 1) || (navigator.msMaxTouchPoints > 1);\r\n                    }\r\n                    // make variable public\r\n                    self.likelyTouchDevice = _likelyTouchDevice;\r\n\r\n                    _globalEventHandlers[_dragStartEvent] = _onDragStart;\r\n                    _globalEventHandlers[_dragMoveEvent] = _onDragMove;\r\n                    _globalEventHandlers[_dragEndEvent] = _onDragRelease; // the Kraken\r\n\r\n                    if (_dragCancelEvent) {\r\n                        _globalEventHandlers[_dragCancelEvent] = _globalEventHandlers[_dragEndEvent];\r\n                    }\r\n\r\n                    // Bind mouse events on device with detected hardware touch support, in case it supports multiple types of input.\r\n                    if (_features.touch) {\r\n                        _downEvents += ' mousedown';\r\n                        _upMoveEvents += ' mousemove mouseup';\r\n                        _globalEventHandlers.mousedown = _globalEventHandlers[_dragStartEvent];\r\n                        _globalEventHandlers.mousemove = _globalEventHandlers[_dragMoveEvent];\r\n                        _globalEventHandlers.mouseup = _globalEventHandlers[_dragEndEvent];\r\n                    }\r\n\r\n                    if (!_likelyTouchDevice) {\r\n                        // don't allow pan to next slide from zoomed state on Desktop\r\n                        _options.allowPanToNext = false;\r\n                    }\r\n                }\r\n\r\n            }\r\n        });\r\n\r\n\r\n        /*>>gestures*/\r\n\r\n        /*>>show-hide-transition*/\r\n        /**\r\n         * show-hide-transition.js:\r\n         *\r\n         * Manages initial opening or closing transition.\r\n         *\r\n         * If you're not planning to use transition for gallery at all,\r\n         * you may set options hideAnimationDuration and showAnimationDuration to 0,\r\n         * and just delete startAnimation function.\r\n         * \r\n         */\r\n\r\n\r\n        var _showOrHideTimeout,\r\n            _showOrHide = function(item, img, out, completeFn) {\r\n\r\n                if (_showOrHideTimeout) {\r\n                    clearTimeout(_showOrHideTimeout);\r\n                }\r\n\r\n                _initialZoomRunning = true;\r\n                _initialContentSet = true;\r\n\r\n                // dimensions of small thumbnail {x:,y:,w:}.\r\n                // Height is optional, as calculated based on large image.\r\n                var thumbBounds;\r\n                if (item.initialLayout) {\r\n                    thumbBounds = item.initialLayout;\r\n                    item.initialLayout = null;\r\n                } else {\r\n                    thumbBounds = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);\r\n                }\r\n\r\n                var duration = out ? _options.hideAnimationDuration : _options.showAnimationDuration;\r\n\r\n                var onComplete = function() {\r\n                    _stopAnimation('initialZoom');\r\n                    if (!out) {\r\n                        _applyBgOpacity(1);\r\n                        if (img) {\r\n                            img.style.display = 'block';\r\n                        }\r\n                        framework.addClass(template, 'pswp--animated-in');\r\n                        _shout('initialZoom' + (out ? 'OutEnd' : 'InEnd'));\r\n                    } else {\r\n                        self.template.removeAttribute('style');\r\n                        self.bg.removeAttribute('style');\r\n                    }\r\n\r\n                    if (completeFn) {\r\n                        completeFn();\r\n                    }\r\n                    _initialZoomRunning = false;\r\n                };\r\n\r\n                // if bounds aren't provided, just open gallery without animation\r\n                if (!duration || !thumbBounds || thumbBounds.x === undefined) {\r\n\r\n                    _shout('initialZoom' + (out ? 'Out' : 'In'));\r\n\r\n                    _currZoomLevel = item.initialZoomLevel;\r\n                    _equalizePoints(_panOffset, item.initialPosition);\r\n                    _applyCurrentZoomPan();\r\n\r\n                    template.style.opacity = out ? 0 : 1;\r\n                    _applyBgOpacity(1);\r\n\r\n                    if (duration) {\r\n                        setTimeout(function() {\r\n                            onComplete();\r\n                        }, duration);\r\n                    } else {\r\n                        onComplete();\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                var startAnimation = function() {\r\n                    var closeWithRaf = _closedByScroll,\r\n                        fadeEverything = !self.currItem.src || self.currItem.loadError || _options.showHideOpacity;\r\n\r\n                    // apply hw-acceleration to image\r\n                    if (item.miniImg) {\r\n                        item.miniImg.style.webkitBackfaceVisibility = 'hidden';\r\n                    }\r\n\r\n                    if (!out) {\r\n                        _currZoomLevel = thumbBounds.w / item.w;\r\n                        _panOffset.x = thumbBounds.x;\r\n                        _panOffset.y = thumbBounds.y - _initalWindowScrollY;\r\n\r\n                        self[fadeEverything ? 'template' : 'bg'].style.opacity = 0.001;\r\n                        _applyCurrentZoomPan();\r\n                    }\r\n\r\n                    _registerStartAnimation('initialZoom');\r\n\r\n                    if (out && !closeWithRaf) {\r\n                        framework.removeClass(template, 'pswp--animated-in');\r\n                    }\r\n\r\n                    if (fadeEverything) {\r\n                        if (out) {\r\n                            framework[(closeWithRaf ? 'remove' : 'add') + 'Class'](template, 'pswp--animate_opacity');\r\n                        } else {\r\n                            setTimeout(function() {\r\n                                framework.addClass(template, 'pswp--animate_opacity');\r\n                            }, 30);\r\n                        }\r\n                    }\r\n\r\n                    _showOrHideTimeout = setTimeout(function() {\r\n\r\n                        _shout('initialZoom' + (out ? 'Out' : 'In'));\r\n\r\n\r\n                        if (!out) {\r\n\r\n                            // \"in\" animation always uses CSS transitions (instead of rAF).\r\n                            // CSS transition work faster here, \r\n                            // as developer may also want to animate other things, \r\n                            // like ui on top of sliding area, which can be animated just via CSS\r\n\r\n                            _currZoomLevel = item.initialZoomLevel;\r\n                            _equalizePoints(_panOffset, item.initialPosition);\r\n                            _applyCurrentZoomPan();\r\n                            _applyBgOpacity(1);\r\n\r\n                            if (fadeEverything) {\r\n                                template.style.opacity = 1;\r\n                            } else {\r\n                                _applyBgOpacity(1);\r\n                            }\r\n\r\n                            _showOrHideTimeout = setTimeout(onComplete, duration + 20);\r\n                        } else {\r\n\r\n                            // \"out\" animation uses rAF only when PhotoSwipe is closed by browser scroll, to recalculate position\r\n                            var destZoomLevel = thumbBounds.w / item.w,\r\n                                initialPanOffset = {\r\n                                    x: _panOffset.x,\r\n                                    y: _panOffset.y\r\n                                },\r\n                                initialZoomLevel = _currZoomLevel,\r\n                                initalBgOpacity = _bgOpacity,\r\n                                onUpdate = function(now) {\r\n\r\n                                    if (now === 1) {\r\n                                        _currZoomLevel = destZoomLevel;\r\n                                        _panOffset.x = thumbBounds.x;\r\n                                        _panOffset.y = thumbBounds.y - _currentWindowScrollY;\r\n                                    } else {\r\n                                        _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;\r\n                                        _panOffset.x = (thumbBounds.x - initialPanOffset.x) * now + initialPanOffset.x;\r\n                                        _panOffset.y = (thumbBounds.y - _currentWindowScrollY - initialPanOffset.y) * now + initialPanOffset.y;\r\n                                    }\r\n\r\n                                    _applyCurrentZoomPan();\r\n                                    if (fadeEverything) {\r\n                                        template.style.opacity = 1 - now;\r\n                                    } else {\r\n                                        _applyBgOpacity(initalBgOpacity - now * initalBgOpacity);\r\n                                    }\r\n                                };\r\n\r\n                            if (closeWithRaf) {\r\n                                _animateProp('initialZoom', 0, 1, duration, framework.easing.cubic.out, onUpdate, onComplete);\r\n                            } else {\r\n                                onUpdate(1);\r\n                                _showOrHideTimeout = setTimeout(onComplete, duration + 20);\r\n                            }\r\n                        }\r\n\r\n                    }, out ? 25 : 90); // Main purpose of this delay is to give browser time to paint and\r\n                    // create composite layers of PhotoSwipe UI parts (background, controls, caption, arrows).\r\n                    // Which avoids lag at the beginning of scale transition.\r\n                };\r\n                startAnimation();\r\n\r\n\r\n            };\r\n\r\n        /*>>show-hide-transition*/\r\n\r\n        /*>>items-controller*/\r\n        /**\r\n         *\r\n         * Controller manages gallery items, their dimensions, and their content.\r\n         * \r\n         */\r\n\r\n        var _items,\r\n            _tempPanAreaSize = {},\r\n            _imagesToAppendPool = [],\r\n            _initialContentSet,\r\n            _initialZoomRunning,\r\n            _controllerDefaultOptions = {\r\n                index: 0,\r\n                errorMsg: '<div class=\"pswp__error-msg\"><a href=\"%url%\" target=\"_blank\">The image</a> could not be loaded.</div>',\r\n                forceProgressiveLoading: false, // TODO\r\n                preload: [1, 1],\r\n                getNumItemsFn: function() {\r\n                    return _items.length;\r\n                }\r\n            };\r\n\r\n\r\n        var _getItemAt,\r\n            _getNumItems,\r\n            _initialIsLoop,\r\n            _getZeroBounds = function() {\r\n                return {\r\n                    center: { x: 0, y: 0 },\r\n                    max: { x: 0, y: 0 },\r\n                    min: { x: 0, y: 0 }\r\n                };\r\n            },\r\n            _calculateSingleItemPanBounds = function(item, realPanElementW, realPanElementH) {\r\n                var bounds = item.bounds;\r\n\r\n                // position of element when it's centered\r\n                bounds.center.x = Math.round((_tempPanAreaSize.x - realPanElementW) / 2);\r\n                bounds.center.y = Math.round((_tempPanAreaSize.y - realPanElementH) / 2) + item.vGap.top;\r\n\r\n                // maximum pan position\r\n                bounds.max.x = (realPanElementW > _tempPanAreaSize.x) ?\r\n                    Math.round(_tempPanAreaSize.x - realPanElementW) :\r\n                    bounds.center.x;\r\n\r\n                bounds.max.y = (realPanElementH > _tempPanAreaSize.y) ?\r\n                    Math.round(_tempPanAreaSize.y - realPanElementH) + item.vGap.top :\r\n                    bounds.center.y;\r\n\r\n                // minimum pan position\r\n                bounds.min.x = (realPanElementW > _tempPanAreaSize.x) ? 0 : bounds.center.x;\r\n                bounds.min.y = (realPanElementH > _tempPanAreaSize.y) ? item.vGap.top : bounds.center.y;\r\n            },\r\n            _calculateItemSize = function(item, viewportSize, zoomLevel) {\r\n\r\n                if (item.src && !item.loadError) {\r\n                    var isInitial = !zoomLevel;\r\n\r\n                    if (isInitial) {\r\n                        if (!item.vGap) {\r\n                            item.vGap = { top: 0, bottom: 0 };\r\n                        }\r\n                        // allows overriding vertical margin for individual items\r\n                        _shout('parseVerticalMargin', item);\r\n                    }\r\n\r\n\r\n                    _tempPanAreaSize.x = viewportSize.x;\r\n                    _tempPanAreaSize.y = viewportSize.y - item.vGap.top - item.vGap.bottom;\r\n\r\n                    if (isInitial) {\r\n                        var hRatio = _tempPanAreaSize.x / item.w;\r\n                        var vRatio = _tempPanAreaSize.y / item.h;\r\n\r\n                        item.fitRatio = hRatio < vRatio ? hRatio : vRatio;\r\n                        //item.fillRatio = hRatio > vRatio ? hRatio : vRatio;\r\n\r\n                        var scaleMode = _options.scaleMode;\r\n\r\n                        if (scaleMode === 'orig') {\r\n                            zoomLevel = 1;\r\n                        } else if (scaleMode === 'fit') {\r\n                            zoomLevel = item.fitRatio;\r\n                        }\r\n\r\n                        if (zoomLevel > 1) {\r\n                            zoomLevel = 1;\r\n                        }\r\n\r\n                        item.initialZoomLevel = zoomLevel;\r\n\r\n                        if (!item.bounds) {\r\n                            // reuse bounds object\r\n                            item.bounds = _getZeroBounds();\r\n                        }\r\n                    }\r\n\r\n                    if (!zoomLevel) {\r\n                        return;\r\n                    }\r\n\r\n                    _calculateSingleItemPanBounds(item, item.w * zoomLevel, item.h * zoomLevel);\r\n\r\n                    if (isInitial && zoomLevel === item.initialZoomLevel) {\r\n                        item.initialPosition = item.bounds.center;\r\n                    }\r\n\r\n                    return item.bounds;\r\n                } else {\r\n                    item.w = item.h = 0;\r\n                    item.initialZoomLevel = item.fitRatio = 1;\r\n                    item.bounds = _getZeroBounds();\r\n                    item.initialPosition = item.bounds.center;\r\n\r\n                    // if it's not image, we return zero bounds (content is not zoomable)\r\n                    return item.bounds;\r\n                }\r\n\r\n            },\r\n\r\n\r\n\r\n\r\n            _appendImage = function(index, item, baseDiv, img, preventAnimation, keepPlaceholder) {\r\n\r\n\r\n                if (item.loadError) {\r\n                    return;\r\n                }\r\n\r\n                if (img) {\r\n\r\n                    item.imageAppended = true;\r\n                    _setImageSize(item, img, (item === self.currItem && _renderMaxResolution));\r\n\r\n                    baseDiv.appendChild(img);\r\n\r\n                    if (keepPlaceholder) {\r\n                        setTimeout(function() {\r\n                            if (item && item.loaded && item.placeholder) {\r\n                                item.placeholder.style.display = 'none';\r\n                                item.placeholder = null;\r\n                            }\r\n                        }, 500);\r\n                    }\r\n                }\r\n            },\r\n\r\n\r\n\r\n            _preloadImage = function(item) {\r\n                item.loading = true;\r\n                item.loaded = false;\r\n                var img = item.img = framework.createEl('pswp__img', 'img');\r\n                var onComplete = function() {\r\n                    item.loading = false;\r\n                    item.loaded = true;\r\n\r\n                    if (item.loadComplete) {\r\n                        item.loadComplete(item);\r\n                    } else {\r\n                        item.img = null; // no need to store image object\r\n                    }\r\n                    img.onload = img.onerror = null;\r\n                    img = null;\r\n                };\r\n                img.onload = onComplete;\r\n                img.onerror = function() {\r\n                    item.loadError = true;\r\n                    onComplete();\r\n                };\r\n\r\n                img.src = item.src; // + '?a=' + Math.random();\r\n\r\n                return img;\r\n            },\r\n            _checkForError = function(item, cleanUp) {\r\n                if (item.src && item.loadError && item.container) {\r\n\r\n                    if (cleanUp) {\r\n                        item.container.innerHTML = '';\r\n                    }\r\n\r\n                    item.container.innerHTML = _options.errorMsg.replace('%url%', item.src);\r\n                    return true;\r\n\r\n                }\r\n            },\r\n            _setImageSize = function(item, img, maxRes) {\r\n                if (!item.src) {\r\n                    return;\r\n                }\r\n\r\n                if (!img) {\r\n                    img = item.container.lastChild;\r\n                }\r\n\r\n                var w = maxRes ? item.w : Math.round(item.w * item.fitRatio),\r\n                    h = maxRes ? item.h : Math.round(item.h * item.fitRatio);\r\n\r\n                if (item.placeholder && !item.loaded) {\r\n                    item.placeholder.style.width = w + 'px';\r\n                    item.placeholder.style.height = h + 'px';\r\n                }\r\n\r\n                img.style.width = w + 'px';\r\n                img.style.height = h + 'px';\r\n            },\r\n            _appendImagesPool = function() {\r\n\r\n                if (_imagesToAppendPool.length) {\r\n                    var poolItem;\r\n\r\n                    for (var i = 0; i < _imagesToAppendPool.length; i++) {\r\n                        poolItem = _imagesToAppendPool[i];\r\n                        if (poolItem.holder.index === poolItem.index) {\r\n                            _appendImage(poolItem.index, poolItem.item, poolItem.baseDiv, poolItem.img, false, poolItem.clearPlaceholder);\r\n                        }\r\n                    }\r\n                    _imagesToAppendPool = [];\r\n                }\r\n            };\r\n\r\n\r\n\r\n        _registerModule('Controller', {\r\n\r\n            publicMethods: {\r\n\r\n                lazyLoadItem: function(index) {\r\n                    index = _getLoopedId(index);\r\n                    var item = _getItemAt(index);\r\n\r\n                    if (!item || ((item.loaded || item.loading) && !_itemsNeedUpdate)) {\r\n                        return;\r\n                    }\r\n\r\n                    _shout('gettingData', index, item);\r\n\r\n                    if (!item.src) {\r\n                        return;\r\n                    }\r\n\r\n                    _preloadImage(item);\r\n                },\r\n                initController: function() {\r\n                    framework.extend(_options, _controllerDefaultOptions, true);\r\n                    self.items = _items = items;\r\n                    _getItemAt = self.getItemAt;\r\n                    _getNumItems = _options.getNumItemsFn; //self.getNumItems;\r\n\r\n\r\n\r\n                    _initialIsLoop = _options.loop;\r\n                    if (_getNumItems() < 3) {\r\n                        _options.loop = false; // disable loop if less then 3 items\r\n                    }\r\n\r\n                    _listen('beforeChange', function(diff) {\r\n\r\n                        var p = _options.preload,\r\n                            isNext = diff === null ? true : (diff >= 0),\r\n                            preloadBefore = Math.min(p[0], _getNumItems()),\r\n                            preloadAfter = Math.min(p[1], _getNumItems()),\r\n                            i;\r\n\r\n\r\n                        for (i = 1; i <= (isNext ? preloadAfter : preloadBefore); i++) {\r\n                            self.lazyLoadItem(_currentItemIndex + i);\r\n                        }\r\n                        for (i = 1; i <= (isNext ? preloadBefore : preloadAfter); i++) {\r\n                            self.lazyLoadItem(_currentItemIndex - i);\r\n                        }\r\n                    });\r\n\r\n                    _listen('initialLayout', function() {\r\n                        self.currItem.initialLayout = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);\r\n                    });\r\n\r\n                    _listen('mainScrollAnimComplete', _appendImagesPool);\r\n                    _listen('initialZoomInEnd', _appendImagesPool);\r\n\r\n\r\n\r\n                    _listen('destroy', function() {\r\n                        var item;\r\n                        for (var i = 0; i < _items.length; i++) {\r\n                            item = _items[i];\r\n                            // remove reference to DOM elements, for GC\r\n                            if (item.container) {\r\n                                item.container = null;\r\n                            }\r\n                            if (item.placeholder) {\r\n                                item.placeholder = null;\r\n                            }\r\n                            if (item.img) {\r\n                                item.img = null;\r\n                            }\r\n                            if (item.preloader) {\r\n                                item.preloader = null;\r\n                            }\r\n                            if (item.loadError) {\r\n                                item.loaded = item.loadError = false;\r\n                            }\r\n                        }\r\n                        _imagesToAppendPool = null;\r\n                    });\r\n                },\r\n\r\n\r\n                getItemAt: function(index) {\r\n                    if (index >= 0) {\r\n                        return _items[index] !== undefined ? _items[index] : false;\r\n                    }\r\n                    return false;\r\n                },\r\n\r\n                allowProgressiveImg: function() {\r\n                    // 1. Progressive image loading isn't working on webkit/blink \r\n                    //    when hw-acceleration (e.g. translateZ) is applied to IMG element.\r\n                    //    That's why in PhotoSwipe parent element gets zoom transform, not image itself.\r\n                    //    \r\n                    // 2. Progressive image loading sometimes blinks in webkit/blink when applying animation to parent element.\r\n                    //    That's why it's disabled on touch devices (mainly because of swipe transition)\r\n                    //    \r\n                    // 3. Progressive image loading sometimes doesn't work in IE (up to 11).\r\n\r\n                    // Don't allow progressive loading on non-large touch devices\r\n                    return _options.forceProgressiveLoading || !_likelyTouchDevice || _options.mouseUsed || screen.width > 1200;\r\n                    // 1200 - to eliminate touch devices with large screen (like Chromebook Pixel)\r\n                },\r\n\r\n                setContent: function(holder, index) {\r\n\r\n                    if (_options.loop) {\r\n                        index = _getLoopedId(index);\r\n                    }\r\n\r\n                    var prevItem = self.getItemAt(holder.index);\r\n                    if (prevItem) {\r\n                        prevItem.container = null;\r\n                    }\r\n\r\n                    var item = self.getItemAt(index),\r\n                        img;\r\n\r\n                    if (!item) {\r\n                        holder.el.innerHTML = '';\r\n                        return;\r\n                    }\r\n\r\n                    // allow to override data\r\n                    _shout('gettingData', index, item);\r\n\r\n                    holder.index = index;\r\n                    holder.item = item;\r\n\r\n                    // base container DIV is created only once for each of 3 holders\r\n                    var baseDiv = item.container = framework.createEl('pswp__zoom-wrap');\r\n\r\n\r\n\r\n                    if (!item.src && item.html) {\r\n                        if (item.html.tagName) {\r\n                            baseDiv.appendChild(item.html);\r\n                        } else {\r\n                            baseDiv.innerHTML = item.html;\r\n                        }\r\n                    }\r\n\r\n                    _checkForError(item);\r\n\r\n                    _calculateItemSize(item, _viewportSize);\r\n\r\n                    if (item.src && !item.loadError && !item.loaded) {\r\n\r\n                        item.loadComplete = function(item) {\r\n\r\n                            // gallery closed before image finished loading\r\n                            if (!_isOpen) {\r\n                                return;\r\n                            }\r\n\r\n                            // check if holder hasn't changed while image was loading\r\n                            if (holder && holder.index === index) {\r\n                                if (_checkForError(item, true)) {\r\n                                    item.loadComplete = item.img = null;\r\n                                    _calculateItemSize(item, _viewportSize);\r\n                                    _applyZoomPanToItem(item);\r\n\r\n                                    if (holder.index === _currentItemIndex) {\r\n                                        // recalculate dimensions\r\n                                        self.updateCurrZoomItem();\r\n                                    }\r\n                                    return;\r\n                                }\r\n                                if (!item.imageAppended) {\r\n                                    if (_features.transform && (_mainScrollAnimating || _initialZoomRunning)) {\r\n                                        _imagesToAppendPool.push({\r\n                                            item: item,\r\n                                            baseDiv: baseDiv,\r\n                                            img: item.img,\r\n                                            index: index,\r\n                                            holder: holder,\r\n                                            clearPlaceholder: true\r\n                                        });\r\n                                    } else {\r\n                                        _appendImage(index, item, baseDiv, item.img, _mainScrollAnimating || _initialZoomRunning, true);\r\n                                    }\r\n                                } else {\r\n                                    // remove preloader & mini-img\r\n                                    if (!_initialZoomRunning && item.placeholder) {\r\n                                        item.placeholder.style.display = 'none';\r\n                                        item.placeholder = null;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            item.loadComplete = null;\r\n                            item.img = null; // no need to store image element after it's added\r\n\r\n                            _shout('imageLoadComplete', index, item);\r\n                        };\r\n\r\n                        if (framework.features.transform) {\r\n\r\n                            var placeholderClassName = 'pswp__img pswp__img--placeholder';\r\n                            placeholderClassName += (item.msrc ? '' : ' pswp__img--placeholder--blank');\r\n\r\n                            var placeholder = framework.createEl(placeholderClassName, item.msrc ? 'img' : '');\r\n                            if (item.msrc) {\r\n                                placeholder.src = item.msrc;\r\n                            }\r\n\r\n                            _setImageSize(item, placeholder);\r\n\r\n                            baseDiv.appendChild(placeholder);\r\n                            item.placeholder = placeholder;\r\n\r\n                        }\r\n\r\n\r\n\r\n\r\n                        if (!item.loading) {\r\n                            _preloadImage(item);\r\n                        }\r\n\r\n\r\n                        if (self.allowProgressiveImg()) {\r\n                            // just append image\r\n                            if (!_initialContentSet && _features.transform) {\r\n                                _imagesToAppendPool.push({\r\n                                    item: item,\r\n                                    baseDiv: baseDiv,\r\n                                    img: item.img,\r\n                                    index: index,\r\n                                    holder: holder\r\n                                });\r\n                            } else {\r\n                                _appendImage(index, item, baseDiv, item.img, true, true);\r\n                            }\r\n                        }\r\n\r\n                    } else if (item.src && !item.loadError) {\r\n                        // image object is created every time, due to bugs of image loading & delay when switching images\r\n                        img = framework.createEl('pswp__img', 'img');\r\n                        img.style.opacity = 1;\r\n                        img.src = item.src;\r\n                        _setImageSize(item, img);\r\n                        _appendImage(index, item, baseDiv, img, true);\r\n                    }\r\n\r\n\r\n                    if (!_initialContentSet && index === _currentItemIndex) {\r\n                        _currZoomElementStyle = baseDiv.style;\r\n                        _showOrHide(item, (img || item.img));\r\n                    } else {\r\n                        _applyZoomPanToItem(item);\r\n                    }\r\n\r\n                    holder.el.innerHTML = '';\r\n                    holder.el.appendChild(baseDiv);\r\n                },\r\n\r\n                cleanSlide: function(item) {\r\n                    if (item.img) {\r\n                        item.img.onload = item.img.onerror = null;\r\n                    }\r\n                    item.loaded = item.loading = item.img = item.imageAppended = false;\r\n                }\r\n\r\n            }\r\n        });\r\n\r\n        /*>>items-controller*/\r\n\r\n        /*>>tap*/\r\n        /**\r\n         * tap.js:\r\n         *\r\n         * Displatches tap and double-tap events.\r\n         * \r\n         */\r\n\r\n        var tapTimer,\r\n            tapReleasePoint = {},\r\n            _dispatchTapEvent = function(origEvent, releasePoint, pointerType) {\r\n                var e = document.createEvent('CustomEvent'),\r\n                    eDetail = {\r\n                        origEvent: origEvent,\r\n                        target: origEvent.target,\r\n                        releasePoint: releasePoint,\r\n                        pointerType: pointerType || 'touch'\r\n                    };\r\n\r\n                e.initCustomEvent('pswpTap', true, true, eDetail);\r\n                origEvent.target.dispatchEvent(e);\r\n            };\r\n\r\n        _registerModule('Tap', {\r\n            publicMethods: {\r\n                initTap: function() {\r\n                    _listen('firstTouchStart', self.onTapStart);\r\n                    _listen('touchRelease', self.onTapRelease);\r\n                    _listen('destroy', function() {\r\n                        tapReleasePoint = {};\r\n                        tapTimer = null;\r\n                    });\r\n                },\r\n                onTapStart: function(touchList) {\r\n                    if (touchList.length > 1) {\r\n                        clearTimeout(tapTimer);\r\n                        tapTimer = null;\r\n                    }\r\n                },\r\n                onTapRelease: function(e, releasePoint) {\r\n                    if (!releasePoint) {\r\n                        return;\r\n                    }\r\n\r\n                    if (!_moved && !_isMultitouch && !_numAnimations) {\r\n                        var p0 = releasePoint;\r\n                        if (tapTimer) {\r\n                            clearTimeout(tapTimer);\r\n                            tapTimer = null;\r\n\r\n                            // Check if taped on the same place\r\n                            if (_isNearbyPoints(p0, tapReleasePoint)) {\r\n                                _shout('doubleTap', p0);\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        if (releasePoint.type === 'mouse') {\r\n                            _dispatchTapEvent(e, releasePoint, 'mouse');\r\n                            return;\r\n                        }\r\n\r\n                        var clickedTagName = e.target.tagName.toUpperCase();\r\n                        // avoid double tap delay on buttons and elements that have class pswp__single-tap\r\n                        if (clickedTagName === 'BUTTON' || framework.hasClass(e.target, 'pswp__single-tap')) {\r\n                            _dispatchTapEvent(e, releasePoint);\r\n                            return;\r\n                        }\r\n\r\n                        _equalizePoints(tapReleasePoint, p0);\r\n\r\n                        tapTimer = setTimeout(function() {\r\n                            _dispatchTapEvent(e, releasePoint);\r\n                            tapTimer = null;\r\n                        }, 300);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        /*>>tap*/\r\n\r\n        /*>>desktop-zoom*/\r\n        /**\r\n         *\r\n         * desktop-zoom.js:\r\n         *\r\n         * - Binds mousewheel event for paning zoomed image.\r\n         * - Manages \"dragging\", \"zoomed-in\", \"zoom-out\" classes.\r\n         *   (which are used for cursors and zoom icon)\r\n         * - Adds toggleDesktopZoom function.\r\n         * \r\n         */\r\n\r\n        var _wheelDelta;\r\n\r\n        _registerModule('DesktopZoom', {\r\n\r\n            publicMethods: {\r\n\r\n                initDesktopZoom: function() {\r\n\r\n                    if (_oldIE) {\r\n                        // no zoom for old IE (<=8)\r\n                        return;\r\n                    }\r\n\r\n                    if (_likelyTouchDevice) {\r\n                        // if detected hardware touch support, we wait until mouse is used,\r\n                        // and only then apply desktop-zoom features\r\n                        _listen('mouseUsed', function() {\r\n                            self.setupDesktopZoom();\r\n                        });\r\n                    } else {\r\n                        self.setupDesktopZoom(true);\r\n                    }\r\n\r\n                },\r\n\r\n                setupDesktopZoom: function(onInit) {\r\n\r\n                    _wheelDelta = {};\r\n\r\n                    var events = 'wheel mousewheel DOMMouseScroll';\r\n\r\n                    _listen('bindEvents', function() {\r\n                        framework.bind(template, events, self.handleMouseWheel);\r\n                    });\r\n\r\n                    _listen('unbindEvents', function() {\r\n                        if (_wheelDelta) {\r\n                            framework.unbind(template, events, self.handleMouseWheel);\r\n                        }\r\n                    });\r\n\r\n                    self.mouseZoomedIn = false;\r\n\r\n                    var hasDraggingClass,\r\n                        updateZoomable = function() {\r\n                            if (self.mouseZoomedIn) {\r\n                                framework.removeClass(template, 'pswp--zoomed-in');\r\n                                self.mouseZoomedIn = false;\r\n                            }\r\n                            if (_currZoomLevel < 1) {\r\n                                framework.addClass(template, 'pswp--zoom-allowed');\r\n                            } else {\r\n                                framework.removeClass(template, 'pswp--zoom-allowed');\r\n                            }\r\n                            removeDraggingClass();\r\n                        },\r\n                        removeDraggingClass = function() {\r\n                            if (hasDraggingClass) {\r\n                                framework.removeClass(template, 'pswp--dragging');\r\n                                hasDraggingClass = false;\r\n                            }\r\n                        };\r\n\r\n                    _listen('resize', updateZoomable);\r\n                    _listen('afterChange', updateZoomable);\r\n                    _listen('pointerDown', function() {\r\n                        if (self.mouseZoomedIn) {\r\n                            hasDraggingClass = true;\r\n                            framework.addClass(template, 'pswp--dragging');\r\n                        }\r\n                    });\r\n                    _listen('pointerUp', removeDraggingClass);\r\n\r\n                    if (!onInit) {\r\n                        updateZoomable();\r\n                    }\r\n\r\n                },\r\n\r\n                handleMouseWheel: function(e) {\r\n\r\n                    if (_currZoomLevel <= self.currItem.fitRatio) {\r\n                        if (_options.modal) {\r\n\r\n                            if (!_options.closeOnScroll || _numAnimations || _isDragging) {\r\n                                e.preventDefault();\r\n                            } else if (_transformKey && Math.abs(e.deltaY) > 2) {\r\n                                // close PhotoSwipe\r\n                                // if browser supports transforms & scroll changed enough\r\n                                _closedByScroll = true;\r\n                                self.close();\r\n                            }\r\n\r\n                        }\r\n                        return true;\r\n                    }\r\n\r\n                    // allow just one event to fire\r\n                    e.stopPropagation();\r\n\r\n                    // https://developer.mozilla.org/en-US/docs/Web/Events/wheel\r\n                    _wheelDelta.x = 0;\r\n\r\n                    if ('deltaX' in e) {\r\n                        if (e.deltaMode === 1 /* DOM_DELTA_LINE */ ) {\r\n                            // 18 - average line height\r\n                            _wheelDelta.x = e.deltaX * 18;\r\n                            _wheelDelta.y = e.deltaY * 18;\r\n                        } else {\r\n                            _wheelDelta.x = e.deltaX;\r\n                            _wheelDelta.y = e.deltaY;\r\n                        }\r\n                    } else if ('wheelDelta' in e) {\r\n                        if (e.wheelDeltaX) {\r\n                            _wheelDelta.x = -0.16 * e.wheelDeltaX;\r\n                        }\r\n                        if (e.wheelDeltaY) {\r\n                            _wheelDelta.y = -0.16 * e.wheelDeltaY;\r\n                        } else {\r\n                            _wheelDelta.y = -0.16 * e.wheelDelta;\r\n                        }\r\n                    } else if ('detail' in e) {\r\n                        _wheelDelta.y = e.detail;\r\n                    } else {\r\n                        return;\r\n                    }\r\n\r\n                    _calculatePanBounds(_currZoomLevel, true);\r\n\r\n                    var newPanX = _panOffset.x - _wheelDelta.x,\r\n                        newPanY = _panOffset.y - _wheelDelta.y;\r\n\r\n                    // only prevent scrolling in nonmodal mode when not at edges\r\n                    if (_options.modal ||\r\n                        (\r\n                            newPanX <= _currPanBounds.min.x && newPanX >= _currPanBounds.max.x &&\r\n                            newPanY <= _currPanBounds.min.y && newPanY >= _currPanBounds.max.y\r\n                        )) {\r\n                        e.preventDefault();\r\n                    }\r\n\r\n                    // TODO: use rAF instead of mousewheel?\r\n                    self.panTo(newPanX, newPanY);\r\n                },\r\n\r\n                toggleDesktopZoom: function(centerPoint) {\r\n                    centerPoint = centerPoint || { x: _viewportSize.x / 2 + _offset.x, y: _viewportSize.y / 2 + _offset.y };\r\n\r\n                    var doubleTapZoomLevel = _options.getDoubleTapZoom(true, self.currItem);\r\n                    var zoomOut = _currZoomLevel === doubleTapZoomLevel;\r\n\r\n                    self.mouseZoomedIn = !zoomOut;\r\n\r\n                    self.zoomTo(zoomOut ? self.currItem.initialZoomLevel : doubleTapZoomLevel, centerPoint, 333);\r\n                    framework[(!zoomOut ? 'add' : 'remove') + 'Class'](template, 'pswp--zoomed-in');\r\n                }\r\n\r\n            }\r\n        });\r\n\r\n\r\n        /*>>desktop-zoom*/\r\n\r\n        /*>>history*/\r\n        /**\r\n         *\r\n         * history.js:\r\n         *\r\n         * - Back button to close gallery.\r\n         * \r\n         * - Unique URL for each slide: example.com/&pid=1&gid=3\r\n         *   (where PID is picture index, and GID and gallery index)\r\n         *   \r\n         * - Switch URL when slides change.\r\n         * \r\n         */\r\n\r\n\r\n        var _historyDefaultOptions = {\r\n            history: true,\r\n            galleryUID: 1\r\n        };\r\n\r\n        var _historyUpdateTimeout,\r\n            _hashChangeTimeout,\r\n            _hashAnimCheckTimeout,\r\n            _hashChangedByScript,\r\n            _hashChangedByHistory,\r\n            _hashReseted,\r\n            _initialHash,\r\n            _historyChanged,\r\n            _closedFromURL,\r\n            _urlChangedOnce,\r\n            _windowLoc,\r\n\r\n            _supportsPushState,\r\n\r\n            _getHash = function() {\r\n                return _windowLoc.hash.substring(1);\r\n            },\r\n            _cleanHistoryTimeouts = function() {\r\n\r\n                if (_historyUpdateTimeout) {\r\n                    clearTimeout(_historyUpdateTimeout);\r\n                }\r\n\r\n                if (_hashAnimCheckTimeout) {\r\n                    clearTimeout(_hashAnimCheckTimeout);\r\n                }\r\n            },\r\n\r\n            // pid - Picture index\r\n            // gid - Gallery index\r\n            _parseItemIndexFromURL = function() {\r\n                var hash = _getHash(),\r\n                    params = {};\r\n\r\n                if (hash.length < 5) { // pid=1\r\n                    return params;\r\n                }\r\n\r\n                var i, vars = hash.split('&');\r\n                for (i = 0; i < vars.length; i++) {\r\n                    if (!vars[i]) {\r\n                        continue;\r\n                    }\r\n                    var pair = vars[i].split('=');\r\n                    if (pair.length < 2) {\r\n                        continue;\r\n                    }\r\n                    params[pair[0]] = pair[1];\r\n                }\r\n                if (_options.galleryPIDs) {\r\n                    // detect custom pid in hash and search for it among the items collection\r\n                    var searchfor = params.pid;\r\n                    params.pid = 0; // if custom pid cannot be found, fallback to the first item\r\n                    for (i = 0; i < _items.length; i++) {\r\n                        if (_items[i].pid === searchfor) {\r\n                            params.pid = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    params.pid = parseInt(params.pid, 10) - 1;\r\n                }\r\n                if (params.pid < 0) {\r\n                    params.pid = 0;\r\n                }\r\n                return params;\r\n            },\r\n            _updateHash = function() {\r\n\r\n                if (_hashAnimCheckTimeout) {\r\n                    clearTimeout(_hashAnimCheckTimeout);\r\n                }\r\n\r\n\r\n                if (_numAnimations || _isDragging) {\r\n                    // changing browser URL forces layout/paint in some browsers, which causes noticable lag during animation\r\n                    // that's why we update hash only when no animations running\r\n                    _hashAnimCheckTimeout = setTimeout(_updateHash, 500);\r\n                    return;\r\n                }\r\n\r\n                if (_hashChangedByScript) {\r\n                    clearTimeout(_hashChangeTimeout);\r\n                } else {\r\n                    _hashChangedByScript = true;\r\n                }\r\n\r\n\r\n                var pid = (_currentItemIndex + 1);\r\n                var item = _getItemAt(_currentItemIndex);\r\n                if (item.hasOwnProperty('pid')) {\r\n                    // carry forward any custom pid assigned to the item\r\n                    pid = item.pid;\r\n                }\r\n                var newHash = _initialHash + '&' + 'gid=' + _options.galleryUID + '&' + 'pid=' + pid;\r\n\r\n                if (!_historyChanged) {\r\n                    if (_windowLoc.hash.indexOf(newHash) === -1) {\r\n                        _urlChangedOnce = true;\r\n                    }\r\n                    // first time - add new hisory record, then just replace\r\n                }\r\n\r\n                var newURL = _windowLoc.href.split('#')[0] + '#' + newHash;\r\n\r\n                if (_supportsPushState) {\r\n\r\n                    if ('#' + newHash !== window.location.hash) {\r\n                        history[_historyChanged ? 'replaceState' : 'pushState']('', document.title, newURL);\r\n                    }\r\n\r\n                } else {\r\n                    if (_historyChanged) {\r\n                        _windowLoc.replace(newURL);\r\n                    } else {\r\n                        _windowLoc.hash = newHash;\r\n                    }\r\n                }\r\n\r\n\r\n\r\n                _historyChanged = true;\r\n                _hashChangeTimeout = setTimeout(function() {\r\n                    _hashChangedByScript = false;\r\n                }, 60);\r\n            };\r\n\r\n\r\n\r\n\r\n\r\n        _registerModule('History', {\r\n\r\n\r\n\r\n            publicMethods: {\r\n                initHistory: function() {\r\n\r\n                    framework.extend(_options, _historyDefaultOptions, true);\r\n\r\n                    if (!_options.history) {\r\n                        return;\r\n                    }\r\n\r\n\r\n                    _windowLoc = window.location;\r\n                    _urlChangedOnce = false;\r\n                    _closedFromURL = false;\r\n                    _historyChanged = false;\r\n                    _initialHash = _getHash();\r\n                    _supportsPushState = ('pushState' in history);\r\n\r\n\r\n                    if (_initialHash.indexOf('gid=') > -1) {\r\n                        _initialHash = _initialHash.split('&gid=')[0];\r\n                        _initialHash = _initialHash.split('?gid=')[0];\r\n                    }\r\n\r\n\r\n                    _listen('afterChange', self.updateURL);\r\n                    _listen('unbindEvents', function() {\r\n                        framework.unbind(window, 'hashchange', self.onHashChange);\r\n                    });\r\n\r\n\r\n                    var returnToOriginal = function() {\r\n                        _hashReseted = true;\r\n                        if (!_closedFromURL) {\r\n\r\n                            if (_urlChangedOnce) {\r\n                                history.back();\r\n                            } else {\r\n\r\n                                if (_initialHash) {\r\n                                    _windowLoc.hash = _initialHash;\r\n                                } else {\r\n                                    if (_supportsPushState) {\r\n\r\n                                        // remove hash from url without refreshing it or scrolling to top\r\n                                        history.pushState('', document.title, _windowLoc.pathname + _windowLoc.search);\r\n                                    } else {\r\n                                        _windowLoc.hash = '';\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        _cleanHistoryTimeouts();\r\n                    };\r\n\r\n\r\n                    _listen('unbindEvents', function() {\r\n                        if (_closedByScroll) {\r\n                            // if PhotoSwipe is closed by scroll, we go \"back\" before the closing animation starts\r\n                            // this is done to keep the scroll position\r\n                            returnToOriginal();\r\n                        }\r\n                    });\r\n                    _listen('destroy', function() {\r\n                        if (!_hashReseted) {\r\n                            returnToOriginal();\r\n                        }\r\n                    });\r\n                    _listen('firstUpdate', function() {\r\n                        _currentItemIndex = _parseItemIndexFromURL().pid;\r\n                    });\r\n\r\n\r\n\r\n\r\n                    var index = _initialHash.indexOf('pid=');\r\n                    if (index > -1) {\r\n                        _initialHash = _initialHash.substring(0, index);\r\n                        if (_initialHash.slice(-1) === '&') {\r\n                            _initialHash = _initialHash.slice(0, -1);\r\n                        }\r\n                    }\r\n\r\n\r\n                    setTimeout(function() {\r\n                        if (_isOpen) { // hasn't destroyed yet\r\n                            framework.bind(window, 'hashchange', self.onHashChange);\r\n                        }\r\n                    }, 40);\r\n\r\n                },\r\n                onHashChange: function() {\r\n\r\n                    if (_getHash() === _initialHash) {\r\n\r\n                        _closedFromURL = true;\r\n                        self.close();\r\n                        return;\r\n                    }\r\n                    if (!_hashChangedByScript) {\r\n\r\n                        _hashChangedByHistory = true;\r\n                        self.goTo(_parseItemIndexFromURL().pid);\r\n                        _hashChangedByHistory = false;\r\n                    }\r\n\r\n                },\r\n                updateURL: function() {\r\n\r\n                    // Delay the update of URL, to avoid lag during transition, \r\n                    // and to not to trigger actions like \"refresh page sound\" or \"blinking favicon\" to often\r\n\r\n                    _cleanHistoryTimeouts();\r\n\r\n\r\n                    if (_hashChangedByHistory) {\r\n                        return;\r\n                    }\r\n\r\n                    if (!_historyChanged) {\r\n                        _updateHash(); // first time\r\n                    } else {\r\n                        _historyUpdateTimeout = setTimeout(_updateHash, 800);\r\n                    }\r\n                }\r\n\r\n            }\r\n        });\r\n\r\n\r\n        /*>>history*/\r\n        framework.extend(self, publicMethods);\r\n    };\r\n    return PhotoSwipe;\r\n});","/*! PhotoSwipe Default UI - 4.1.2 - 2017-04-05\r\n * http://photoswipe.com\r\n * Copyright (c) 2017 Dmitry Semenov; */\r\n/**\r\n *\r\n * UI on top of main sliding area (caption, arrows, close button, etc.).\r\n * Built just using public methods/properties of PhotoSwipe.\r\n * \r\n */\r\n(function(root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(factory);\r\n    } else if (typeof exports === 'object') {\r\n        module.exports = factory();\r\n    } else {\r\n        root.PhotoSwipeUI_Default = factory();\r\n    }\r\n})(this, function() {\r\n\r\n    'use strict';\r\n\r\n\r\n\r\n    var PhotoSwipeUI_Default =\r\n        function(pswp, framework) {\r\n\r\n            var ui = this;\r\n            var _overlayUIUpdated = false,\r\n                _controlsVisible = true,\r\n                _fullscrenAPI,\r\n                _controls,\r\n                _captionContainer,\r\n                _fakeCaptionContainer,\r\n                _indexIndicator,\r\n                _shareButton,\r\n                _shareModal,\r\n                _shareModalHidden = true,\r\n                _initalCloseOnScrollValue,\r\n                _isIdle,\r\n                _listen,\r\n\r\n                _loadingIndicator,\r\n                _loadingIndicatorHidden,\r\n                _loadingIndicatorTimeout,\r\n\r\n                _galleryHasOneSlide,\r\n\r\n                _options,\r\n                _defaultUIOptions = {\r\n                    barsSize: { top: 44, bottom: 'auto' },\r\n                    closeElClasses: ['item', 'caption', 'zoom-wrap', 'ui', 'top-bar'],\r\n                    timeToIdle: 4000,\r\n                    timeToIdleOutside: 1000,\r\n                    loadingIndicatorDelay: 1000, // 2s\r\n\r\n                    addCaptionHTMLFn: function(item, captionEl /*, isFake */ ) {\r\n                        if (!item.title) {\r\n                            captionEl.children[0].innerHTML = '';\r\n                            return false;\r\n                        }\r\n                        captionEl.children[0].innerHTML = item.title;\r\n                        return true;\r\n                    },\r\n\r\n                    closeEl: true,\r\n                    captionEl: true,\r\n                    fullscreenEl: true,\r\n                    zoomEl: true,\r\n                    shareEl: true,\r\n                    counterEl: true,\r\n                    arrowEl: true,\r\n                    preloaderEl: true,\r\n\r\n                    tapToClose: false,\r\n                    tapToToggleControls: true,\r\n\r\n                    clickToCloseNonZoomable: true,\r\n\r\n                    shareButtons: [\r\n                        { id: 'facebook', label: 'Share on Facebook', url: 'https://www.facebook.com/sharer/sharer.php?u={{url}}' },\r\n                        { id: 'twitter', label: 'Tweet', url: 'https://twitter.com/intent/tweet?text={{text}}&url={{url}}' },\r\n                        {\r\n                            id: 'pinterest',\r\n                            label: 'Pin it',\r\n                            url: 'http://www.pinterest.com/pin/create/button/' +\r\n                                '?url={{url}}&media={{image_url}}&description={{text}}'\r\n                        },\r\n                        { id: 'download', label: 'Download image', url: '{{raw_image_url}}', download: true }\r\n                    ],\r\n                    getImageURLForShare: function( /* shareButtonData */ ) {\r\n                        return pswp.currItem.src || '';\r\n                    },\r\n                    getPageURLForShare: function( /* shareButtonData */ ) {\r\n                        return window.location.href;\r\n                    },\r\n                    getTextForShare: function( /* shareButtonData */ ) {\r\n                        return pswp.currItem.title || '';\r\n                    },\r\n\r\n                    indexIndicatorSep: ' / ',\r\n                    fitControlsWidth: 1200\r\n\r\n                },\r\n                _blockControlsTap,\r\n                _blockControlsTapTimeout;\r\n\r\n\r\n\r\n            var _onControlsTap = function(e) {\r\n                    if (_blockControlsTap) {\r\n                        return true;\r\n                    }\r\n\r\n\r\n                    e = e || window.event;\r\n\r\n                    if (_options.timeToIdle && _options.mouseUsed && !_isIdle) {\r\n                        // reset idle timer\r\n                        _onIdleMouseMove();\r\n                    }\r\n\r\n\r\n                    var target = e.target || e.srcElement,\r\n                        uiElement,\r\n                        clickedClass = target.getAttribute('class') || '',\r\n                        found;\r\n\r\n                    for (var i = 0; i < _uiElements.length; i++) {\r\n                        uiElement = _uiElements[i];\r\n                        if (uiElement.onTap && clickedClass.indexOf('pswp__' + uiElement.name) > -1) {\r\n                            uiElement.onTap();\r\n                            found = true;\r\n\r\n                        }\r\n                    }\r\n\r\n                    if (found) {\r\n                        if (e.stopPropagation) {\r\n                            e.stopPropagation();\r\n                        }\r\n                        _blockControlsTap = true;\r\n\r\n                        // Some versions of Android don't prevent ghost click event \r\n                        // when preventDefault() was called on touchstart and/or touchend.\r\n                        // \r\n                        // This happens on v4.3, 4.2, 4.1, \r\n                        // older versions strangely work correctly, \r\n                        // but just in case we add delay on all of them)\t\r\n                        var tapDelay = framework.features.isOldAndroid ? 600 : 30;\r\n                        _blockControlsTapTimeout = setTimeout(function() {\r\n                            _blockControlsTap = false;\r\n                        }, tapDelay);\r\n                    }\r\n\r\n                },\r\n                _fitControlsInViewport = function() {\r\n                    return !pswp.likelyTouchDevice || _options.mouseUsed || screen.width > _options.fitControlsWidth;\r\n                },\r\n                _togglePswpClass = function(el, cName, add) {\r\n                    framework[(add ? 'add' : 'remove') + 'Class'](el, 'pswp__' + cName);\r\n                },\r\n\r\n                // add class when there is just one item in the gallery\r\n                // (by default it hides left/right arrows and 1ofX counter)\r\n                _countNumItems = function() {\r\n                    var hasOneSlide = (_options.getNumItemsFn() === 1);\r\n\r\n                    if (hasOneSlide !== _galleryHasOneSlide) {\r\n                        _togglePswpClass(_controls, 'ui--one-slide', hasOneSlide);\r\n                        _galleryHasOneSlide = hasOneSlide;\r\n                    }\r\n                },\r\n                _toggleShareModalClass = function() {\r\n                    _togglePswpClass(_shareModal, 'share-modal--hidden', _shareModalHidden);\r\n                },\r\n                _toggleShareModal = function() {\r\n\r\n                    _shareModalHidden = !_shareModalHidden;\r\n\r\n\r\n                    if (!_shareModalHidden) {\r\n                        _toggleShareModalClass();\r\n                        setTimeout(function() {\r\n                            if (!_shareModalHidden) {\r\n                                framework.addClass(_shareModal, 'pswp__share-modal--fade-in');\r\n                            }\r\n                        }, 30);\r\n                    } else {\r\n                        framework.removeClass(_shareModal, 'pswp__share-modal--fade-in');\r\n                        setTimeout(function() {\r\n                            if (_shareModalHidden) {\r\n                                _toggleShareModalClass();\r\n                            }\r\n                        }, 300);\r\n                    }\r\n\r\n                    if (!_shareModalHidden) {\r\n                        _updateShareURLs();\r\n                    }\r\n                    return false;\r\n                },\r\n\r\n                _openWindowPopup = function(e) {\r\n                    e = e || window.event;\r\n                    var target = e.target || e.srcElement;\r\n\r\n                    pswp.shout('shareLinkClick', e, target);\r\n\r\n                    if (!target.href) {\r\n                        return false;\r\n                    }\r\n\r\n                    if (target.hasAttribute('download')) {\r\n                        return true;\r\n                    }\r\n\r\n                    window.open(target.href, 'pswp_share', 'scrollbars=yes,resizable=yes,toolbar=no,' +\r\n                        'location=yes,width=550,height=420,top=100,left=' +\r\n                        (window.screen ? Math.round(screen.width / 2 - 275) : 100));\r\n\r\n                    if (!_shareModalHidden) {\r\n                        _toggleShareModal();\r\n                    }\r\n\r\n                    return false;\r\n                },\r\n                _updateShareURLs = function() {\r\n                    var shareButtonOut = '',\r\n                        shareButtonData,\r\n                        shareURL,\r\n                        image_url,\r\n                        page_url,\r\n                        share_text;\r\n\r\n                    for (var i = 0; i < _options.shareButtons.length; i++) {\r\n                        shareButtonData = _options.shareButtons[i];\r\n\r\n                        image_url = _options.getImageURLForShare(shareButtonData);\r\n                        page_url = _options.getPageURLForShare(shareButtonData);\r\n                        share_text = _options.getTextForShare(shareButtonData);\r\n\r\n                        shareURL = shareButtonData.url.replace('{{url}}', encodeURIComponent(page_url))\r\n                            .replace('{{image_url}}', encodeURIComponent(image_url))\r\n                            .replace('{{raw_image_url}}', image_url)\r\n                            .replace('{{text}}', encodeURIComponent(share_text));\r\n\r\n                        shareButtonOut += '<a href=\"' + shareURL + '\" target=\"_blank\" ' +\r\n                            'class=\"pswp__share--' + shareButtonData.id + '\"' +\r\n                            (shareButtonData.download ? 'download' : '') + '>' +\r\n                            shareButtonData.label + '</a>';\r\n\r\n                        if (_options.parseShareButtonOut) {\r\n                            shareButtonOut = _options.parseShareButtonOut(shareButtonData, shareButtonOut);\r\n                        }\r\n                    }\r\n                    _shareModal.children[0].innerHTML = shareButtonOut;\r\n                    _shareModal.children[0].onclick = _openWindowPopup;\r\n\r\n                },\r\n                _hasCloseClass = function(target) {\r\n                    for (var i = 0; i < _options.closeElClasses.length; i++) {\r\n                        if (framework.hasClass(target, 'pswp__' + _options.closeElClasses[i])) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                },\r\n                _idleInterval,\r\n                _idleTimer,\r\n                _idleIncrement = 0,\r\n                _onIdleMouseMove = function() {\r\n                    clearTimeout(_idleTimer);\r\n                    _idleIncrement = 0;\r\n                    if (_isIdle) {\r\n                        ui.setIdle(false);\r\n                    }\r\n                },\r\n                _onMouseLeaveWindow = function(e) {\r\n                    e = e ? e : window.event;\r\n                    var from = e.relatedTarget || e.toElement;\r\n                    if (!from || from.nodeName === 'HTML') {\r\n                        clearTimeout(_idleTimer);\r\n                        _idleTimer = setTimeout(function() {\r\n                            ui.setIdle(true);\r\n                        }, _options.timeToIdleOutside);\r\n                    }\r\n                },\r\n                _setupFullscreenAPI = function() {\r\n                    if (_options.fullscreenEl && !framework.features.isOldAndroid) {\r\n                        if (!_fullscrenAPI) {\r\n                            _fullscrenAPI = ui.getFullscreenAPI();\r\n                        }\r\n                        if (_fullscrenAPI) {\r\n                            framework.bind(document, _fullscrenAPI.eventK, ui.updateFullscreen);\r\n                            ui.updateFullscreen();\r\n                            framework.addClass(pswp.template, 'pswp--supports-fs');\r\n                        } else {\r\n                            framework.removeClass(pswp.template, 'pswp--supports-fs');\r\n                        }\r\n                    }\r\n                },\r\n                _setupLoadingIndicator = function() {\r\n                    // Setup loading indicator\r\n                    if (_options.preloaderEl) {\r\n\r\n                        _toggleLoadingIndicator(true);\r\n\r\n                        _listen('beforeChange', function() {\r\n\r\n                            clearTimeout(_loadingIndicatorTimeout);\r\n\r\n                            // display loading indicator with delay\r\n                            _loadingIndicatorTimeout = setTimeout(function() {\r\n\r\n                                if (pswp.currItem && pswp.currItem.loading) {\r\n\r\n                                    if (!pswp.allowProgressiveImg() || (pswp.currItem.img && !pswp.currItem.img.naturalWidth)) {\r\n                                        // show preloader if progressive loading is not enabled, \r\n                                        // or image width is not defined yet (because of slow connection)\r\n                                        _toggleLoadingIndicator(false);\r\n                                        // items-controller.js function allowProgressiveImg\r\n                                    }\r\n\r\n                                } else {\r\n                                    _toggleLoadingIndicator(true); // hide preloader\r\n                                }\r\n\r\n                            }, _options.loadingIndicatorDelay);\r\n\r\n                        });\r\n                        _listen('imageLoadComplete', function(index, item) {\r\n                            if (pswp.currItem === item) {\r\n                                _toggleLoadingIndicator(true);\r\n                            }\r\n                        });\r\n\r\n                    }\r\n                },\r\n                _toggleLoadingIndicator = function(hide) {\r\n                    if (_loadingIndicatorHidden !== hide) {\r\n                        _togglePswpClass(_loadingIndicator, 'preloader--active', !hide);\r\n                        _loadingIndicatorHidden = hide;\r\n                    }\r\n                },\r\n                _applyNavBarGaps = function(item) {\r\n                    var gap = item.vGap;\r\n\r\n                    if (_fitControlsInViewport()) {\r\n\r\n                        var bars = _options.barsSize;\r\n                        if (_options.captionEl && bars.bottom === 'auto') {\r\n                            if (!_fakeCaptionContainer) {\r\n                                _fakeCaptionContainer = framework.createEl('pswp__caption pswp__caption--fake');\r\n                                _fakeCaptionContainer.appendChild(framework.createEl('pswp__caption__center'));\r\n                                _controls.insertBefore(_fakeCaptionContainer, _captionContainer);\r\n                                framework.addClass(_controls, 'pswp__ui--fit');\r\n                            }\r\n                            if (_options.addCaptionHTMLFn(item, _fakeCaptionContainer, true)) {\r\n\r\n                                var captionSize = _fakeCaptionContainer.clientHeight;\r\n                                gap.bottom = parseInt(captionSize, 10) || 44;\r\n                            } else {\r\n                                gap.bottom = bars.top; // if no caption, set size of bottom gap to size of top\r\n                            }\r\n                        } else {\r\n                            gap.bottom = bars.bottom === 'auto' ? 0 : bars.bottom;\r\n                        }\r\n\r\n                        // height of top bar is static, no need to calculate it\r\n                        gap.top = bars.top;\r\n                    } else {\r\n                        gap.top = gap.bottom = 0;\r\n                    }\r\n                },\r\n                _setupIdle = function() {\r\n                    // Hide controls when mouse is used\r\n                    if (_options.timeToIdle) {\r\n                        _listen('mouseUsed', function() {\r\n\r\n                            framework.bind(document, 'mousemove', _onIdleMouseMove);\r\n                            framework.bind(document, 'mouseout', _onMouseLeaveWindow);\r\n\r\n                            _idleInterval = setInterval(function() {\r\n                                _idleIncrement++;\r\n                                if (_idleIncrement === 2) {\r\n                                    ui.setIdle(true);\r\n                                }\r\n                            }, _options.timeToIdle / 2);\r\n                        });\r\n                    }\r\n                },\r\n                _setupHidingControlsDuringGestures = function() {\r\n\r\n                    // Hide controls on vertical drag\r\n                    _listen('onVerticalDrag', function(now) {\r\n                        if (_controlsVisible && now < 0.95) {\r\n                            ui.hideControls();\r\n                        } else if (!_controlsVisible && now >= 0.95) {\r\n                            ui.showControls();\r\n                        }\r\n                    });\r\n\r\n                    // Hide controls when pinching to close\r\n                    var pinchControlsHidden;\r\n                    _listen('onPinchClose', function(now) {\r\n                        if (_controlsVisible && now < 0.9) {\r\n                            ui.hideControls();\r\n                            pinchControlsHidden = true;\r\n                        } else if (pinchControlsHidden && !_controlsVisible && now > 0.9) {\r\n                            ui.showControls();\r\n                        }\r\n                    });\r\n\r\n                    _listen('zoomGestureEnded', function() {\r\n                        pinchControlsHidden = false;\r\n                        if (pinchControlsHidden && !_controlsVisible) {\r\n                            ui.showControls();\r\n                        }\r\n                    });\r\n\r\n                };\r\n\r\n\r\n\r\n            var _uiElements = [{\r\n                    name: 'caption',\r\n                    option: 'captionEl',\r\n                    onInit: function(el) {\r\n                        _captionContainer = el;\r\n                    }\r\n                },\r\n                {\r\n                    name: 'share-modal',\r\n                    option: 'shareEl',\r\n                    onInit: function(el) {\r\n                        _shareModal = el;\r\n                    },\r\n                    onTap: function() {\r\n                        _toggleShareModal();\r\n                    }\r\n                },\r\n                {\r\n                    name: 'button--share',\r\n                    option: 'shareEl',\r\n                    onInit: function(el) {\r\n                        _shareButton = el;\r\n                    },\r\n                    onTap: function() {\r\n                        _toggleShareModal();\r\n                    }\r\n                },\r\n                {\r\n                    name: 'button--zoom',\r\n                    option: 'zoomEl',\r\n                    onTap: pswp.toggleDesktopZoom\r\n                },\r\n                {\r\n                    name: 'counter',\r\n                    option: 'counterEl',\r\n                    onInit: function(el) {\r\n                        _indexIndicator = el;\r\n                    }\r\n                },\r\n                {\r\n                    name: 'button--close',\r\n                    option: 'closeEl',\r\n                    onTap: pswp.close\r\n                },\r\n                {\r\n                    name: 'button--arrow--left',\r\n                    option: 'arrowEl',\r\n                    onTap: pswp.prev\r\n                },\r\n                {\r\n                    name: 'button--arrow--right',\r\n                    option: 'arrowEl',\r\n                    onTap: pswp.next\r\n                },\r\n                {\r\n                    name: 'button--fs',\r\n                    option: 'fullscreenEl',\r\n                    onTap: function() {\r\n                        if (_fullscrenAPI.isFullscreen()) {\r\n                            _fullscrenAPI.exit();\r\n                        } else {\r\n                            _fullscrenAPI.enter();\r\n                        }\r\n                    }\r\n                },\r\n                {\r\n                    name: 'preloader',\r\n                    option: 'preloaderEl',\r\n                    onInit: function(el) {\r\n                        _loadingIndicator = el;\r\n                    }\r\n                }\r\n\r\n            ];\r\n\r\n            var _setupUIElements = function() {\r\n                var item,\r\n                    classAttr,\r\n                    uiElement;\r\n\r\n                var loopThroughChildElements = function(sChildren) {\r\n                    if (!sChildren) {\r\n                        return;\r\n                    }\r\n\r\n                    var l = sChildren.length;\r\n                    for (var i = 0; i < l; i++) {\r\n                        item = sChildren[i];\r\n                        classAttr = item.className;\r\n\r\n                        for (var a = 0; a < _uiElements.length; a++) {\r\n                            uiElement = _uiElements[a];\r\n\r\n                            if (classAttr.indexOf('pswp__' + uiElement.name) > -1) {\r\n\r\n                                if (_options[uiElement.option]) { // if element is not disabled from options\r\n\r\n                                    framework.removeClass(item, 'pswp__element--disabled');\r\n                                    if (uiElement.onInit) {\r\n                                        uiElement.onInit(item);\r\n                                    }\r\n\r\n                                    //item.style.display = 'block';\r\n                                } else {\r\n                                    framework.addClass(item, 'pswp__element--disabled');\r\n                                    //item.style.display = 'none';\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n                loopThroughChildElements(_controls.children);\r\n\r\n                var topBar = framework.getChildByClass(_controls, 'pswp__top-bar');\r\n                if (topBar) {\r\n                    loopThroughChildElements(topBar.children);\r\n                }\r\n            };\r\n\r\n\r\n\r\n\r\n            ui.init = function() {\r\n\r\n                // extend options\r\n                framework.extend(pswp.options, _defaultUIOptions, true);\r\n\r\n                // create local link for fast access\r\n                _options = pswp.options;\r\n\r\n                // find pswp__ui element\r\n                _controls = framework.getChildByClass(pswp.scrollWrap, 'pswp__ui');\r\n\r\n                // create local link\r\n                _listen = pswp.listen;\r\n\r\n\r\n                _setupHidingControlsDuringGestures();\r\n\r\n                // update controls when slides change\r\n                _listen('beforeChange', ui.update);\r\n\r\n                // toggle zoom on double-tap\r\n                _listen('doubleTap', function(point) {\r\n                    var initialZoomLevel = pswp.currItem.initialZoomLevel;\r\n                    if (pswp.getZoomLevel() !== initialZoomLevel) {\r\n                        pswp.zoomTo(initialZoomLevel, point, 333);\r\n                    } else {\r\n                        pswp.zoomTo(_options.getDoubleTapZoom(false, pswp.currItem), point, 333);\r\n                    }\r\n                });\r\n\r\n                // Allow text selection in caption\r\n                _listen('preventDragEvent', function(e, isDown, preventObj) {\r\n                    var t = e.target || e.srcElement;\r\n                    if (\r\n                        t &&\r\n                        t.getAttribute('class') && e.type.indexOf('mouse') > -1 &&\r\n                        (t.getAttribute('class').indexOf('__caption') > 0 || (/(SMALL|STRONG|EM)/i).test(t.tagName))\r\n                    ) {\r\n                        preventObj.prevent = false;\r\n                    }\r\n                });\r\n\r\n                // bind events for UI\r\n                _listen('bindEvents', function() {\r\n                    framework.bind(_controls, 'pswpTap click', _onControlsTap);\r\n                    framework.bind(pswp.scrollWrap, 'pswpTap', ui.onGlobalTap);\r\n\r\n                    if (!pswp.likelyTouchDevice) {\r\n                        framework.bind(pswp.scrollWrap, 'mouseover', ui.onMouseOver);\r\n                    }\r\n                });\r\n\r\n                // unbind events for UI\r\n                _listen('unbindEvents', function() {\r\n                    if (!_shareModalHidden) {\r\n                        _toggleShareModal();\r\n                    }\r\n\r\n                    if (_idleInterval) {\r\n                        clearInterval(_idleInterval);\r\n                    }\r\n                    framework.unbind(document, 'mouseout', _onMouseLeaveWindow);\r\n                    framework.unbind(document, 'mousemove', _onIdleMouseMove);\r\n                    framework.unbind(_controls, 'pswpTap click', _onControlsTap);\r\n                    framework.unbind(pswp.scrollWrap, 'pswpTap', ui.onGlobalTap);\r\n                    framework.unbind(pswp.scrollWrap, 'mouseover', ui.onMouseOver);\r\n\r\n                    if (_fullscrenAPI) {\r\n                        framework.unbind(document, _fullscrenAPI.eventK, ui.updateFullscreen);\r\n                        if (_fullscrenAPI.isFullscreen()) {\r\n                            _options.hideAnimationDuration = 0;\r\n                            _fullscrenAPI.exit();\r\n                        }\r\n                        _fullscrenAPI = null;\r\n                    }\r\n                });\r\n\r\n\r\n                // clean up things when gallery is destroyed\r\n                _listen('destroy', function() {\r\n                    if (_options.captionEl) {\r\n                        if (_fakeCaptionContainer) {\r\n                            _controls.removeChild(_fakeCaptionContainer);\r\n                        }\r\n                        framework.removeClass(_captionContainer, 'pswp__caption--empty');\r\n                    }\r\n\r\n                    if (_shareModal) {\r\n                        _shareModal.children[0].onclick = null;\r\n                    }\r\n                    framework.removeClass(_controls, 'pswp__ui--over-close');\r\n                    framework.addClass(_controls, 'pswp__ui--hidden');\r\n                    ui.setIdle(false);\r\n                });\r\n\r\n\r\n                if (!_options.showAnimationDuration) {\r\n                    framework.removeClass(_controls, 'pswp__ui--hidden');\r\n                }\r\n                _listen('initialZoomIn', function() {\r\n                    if (_options.showAnimationDuration) {\r\n                        framework.removeClass(_controls, 'pswp__ui--hidden');\r\n                    }\r\n                });\r\n                _listen('initialZoomOut', function() {\r\n                    framework.addClass(_controls, 'pswp__ui--hidden');\r\n                });\r\n\r\n                _listen('parseVerticalMargin', _applyNavBarGaps);\r\n\r\n                _setupUIElements();\r\n\r\n                if (_options.shareEl && _shareButton && _shareModal) {\r\n                    _shareModalHidden = true;\r\n                }\r\n\r\n                _countNumItems();\r\n\r\n                _setupIdle();\r\n\r\n                _setupFullscreenAPI();\r\n\r\n                _setupLoadingIndicator();\r\n            };\r\n\r\n            ui.setIdle = function(isIdle) {\r\n                _isIdle = isIdle;\r\n                _togglePswpClass(_controls, 'ui--idle', isIdle);\r\n            };\r\n\r\n            ui.update = function() {\r\n                // Don't update UI if it's hidden\r\n                if (_controlsVisible && pswp.currItem) {\r\n\r\n                    ui.updateIndexIndicator();\r\n\r\n                    if (_options.captionEl) {\r\n                        _options.addCaptionHTMLFn(pswp.currItem, _captionContainer);\r\n\r\n                        _togglePswpClass(_captionContainer, 'caption--empty', !pswp.currItem.title);\r\n                    }\r\n\r\n                    _overlayUIUpdated = true;\r\n\r\n                } else {\r\n                    _overlayUIUpdated = false;\r\n                }\r\n\r\n                if (!_shareModalHidden) {\r\n                    _toggleShareModal();\r\n                }\r\n\r\n                _countNumItems();\r\n            };\r\n\r\n            ui.updateFullscreen = function(e) {\r\n\r\n                if (e) {\r\n                    // some browsers change window scroll position during the fullscreen\r\n                    // so PhotoSwipe updates it just in case\r\n                    setTimeout(function() {\r\n                        pswp.setScrollOffset(0, framework.getScrollY());\r\n                    }, 50);\r\n                }\r\n\r\n                // toogle pswp--fs class on root element\r\n                framework[(_fullscrenAPI.isFullscreen() ? 'add' : 'remove') + 'Class'](pswp.template, 'pswp--fs');\r\n            };\r\n\r\n            ui.updateIndexIndicator = function() {\r\n                if (_options.counterEl) {\r\n                    _indexIndicator.innerHTML = (pswp.getCurrentIndex() + 1) +\r\n                        _options.indexIndicatorSep +\r\n                        _options.getNumItemsFn();\r\n                }\r\n            };\r\n\r\n            ui.onGlobalTap = function(e) {\r\n                e = e || window.event;\r\n                var target = e.target || e.srcElement;\r\n\r\n                if (_blockControlsTap) {\r\n                    return;\r\n                }\r\n\r\n                if (e.detail && e.detail.pointerType === 'mouse') {\r\n\r\n                    // close gallery if clicked outside of the image\r\n                    if (_hasCloseClass(target)) {\r\n                        pswp.close();\r\n                        return;\r\n                    }\r\n\r\n                    if (framework.hasClass(target, 'pswp__img')) {\r\n                        if (pswp.getZoomLevel() === 1 && pswp.getZoomLevel() <= pswp.currItem.fitRatio) {\r\n                            if (_options.clickToCloseNonZoomable) {\r\n                                pswp.close();\r\n                            }\r\n                        } else {\r\n                            pswp.toggleDesktopZoom(e.detail.releasePoint);\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n\r\n                    // tap anywhere (except buttons) to toggle visibility of controls\r\n                    if (_options.tapToToggleControls) {\r\n                        if (_controlsVisible) {\r\n                            ui.hideControls();\r\n                        } else {\r\n                            ui.showControls();\r\n                        }\r\n                    }\r\n\r\n                    // tap to close gallery\r\n                    if (_options.tapToClose && (framework.hasClass(target, 'pswp__img') || _hasCloseClass(target))) {\r\n                        pswp.close();\r\n                        return;\r\n                    }\r\n\r\n                }\r\n            };\r\n            ui.onMouseOver = function(e) {\r\n                e = e || window.event;\r\n                var target = e.target || e.srcElement;\r\n\r\n                // add class when mouse is over an element that should close the gallery\r\n                _togglePswpClass(_controls, 'ui--over-close', _hasCloseClass(target));\r\n            };\r\n\r\n            ui.hideControls = function() {\r\n                framework.addClass(_controls, 'pswp__ui--hidden');\r\n                _controlsVisible = false;\r\n            };\r\n\r\n            ui.showControls = function() {\r\n                _controlsVisible = true;\r\n                if (!_overlayUIUpdated) {\r\n                    ui.update();\r\n                }\r\n                framework.removeClass(_controls, 'pswp__ui--hidden');\r\n            };\r\n\r\n            ui.supportsFullscreen = function() {\r\n                var d = document;\r\n                return !!(d.exitFullscreen || d.mozCancelFullScreen || d.webkitExitFullscreen || d.msExitFullscreen);\r\n            };\r\n\r\n            ui.getFullscreenAPI = function() {\r\n                var dE = document.documentElement,\r\n                    api,\r\n                    tF = 'fullscreenchange';\r\n\r\n                if (dE.requestFullscreen) {\r\n                    api = {\r\n                        enterK: 'requestFullscreen',\r\n                        exitK: 'exitFullscreen',\r\n                        elementK: 'fullscreenElement',\r\n                        eventK: tF\r\n                    };\r\n\r\n                } else if (dE.mozRequestFullScreen) {\r\n                    api = {\r\n                        enterK: 'mozRequestFullScreen',\r\n                        exitK: 'mozCancelFullScreen',\r\n                        elementK: 'mozFullScreenElement',\r\n                        eventK: 'moz' + tF\r\n                    };\r\n\r\n\r\n\r\n                } else if (dE.webkitRequestFullscreen) {\r\n                    api = {\r\n                        enterK: 'webkitRequestFullscreen',\r\n                        exitK: 'webkitExitFullscreen',\r\n                        elementK: 'webkitFullscreenElement',\r\n                        eventK: 'webkit' + tF\r\n                    };\r\n\r\n                } else if (dE.msRequestFullscreen) {\r\n                    api = {\r\n                        enterK: 'msRequestFullscreen',\r\n                        exitK: 'msExitFullscreen',\r\n                        elementK: 'msFullscreenElement',\r\n                        eventK: 'MSFullscreenChange'\r\n                    };\r\n                }\r\n\r\n                if (api) {\r\n                    api.enter = function() {\r\n                        // disable close-on-scroll in fullscreen\r\n                        _initalCloseOnScrollValue = _options.closeOnScroll;\r\n                        _options.closeOnScroll = false;\r\n\r\n                        if (this.enterK === 'webkitRequestFullscreen') {\r\n                            pswp.template[this.enterK](Element.ALLOW_KEYBOARD_INPUT);\r\n                        } else {\r\n                            return pswp.template[this.enterK]();\r\n                        }\r\n                    };\r\n                    api.exit = function() {\r\n                        _options.closeOnScroll = _initalCloseOnScrollValue;\r\n\r\n                        return document[this.exitK]();\r\n\r\n                    };\r\n                    api.isFullscreen = function() { return document[this.elementK]; };\r\n                }\r\n\r\n                return api;\r\n            };\r\n\r\n\r\n\r\n        };\r\n    return PhotoSwipeUI_Default;\r\n\r\n\r\n});"]}